\documentstyle{jfp}
\RequirePackage{alltt}

% added for proper hyphenation:
\righthyphenmin=2
\lefthyphenmin=3

\newcommand{\comment}[1]{}
\newcommand{\mirror}{\mathop{\mathrm{mirror}}}
\newcommand{\suitable}{\mathop{\mathrm{suitable}}}

%% For verbatim displays use the {eopltt} environment, which is like
%% {alltt}, except that it uses the \codefontsize font.
%% {alltt} is like verbatim
%% except that \ { and } work normally.  This allows the most normal use of
%% tex macros inside code segments.  Be glad we're not using Java or C.
%% Or if macros aren't used in the next and there are literal backslashes,
%% use {eoplverbatim}
\def\endofexercise{{~\ $\Diamond$}}
\def\myrule{\raisebox{3.4ex}[1.5ex][.75ex]{\rule{126mm}{.01mm}}{\vspace{-3ex}}\\}
%\def\myrule{\raisebox{6ex}{\rule{126mm}{.01mm}}\\}
\def\codefontsize{\fontsize{9}{10}\selectfont\tt}
\def\inlinecode#1{\hbox{\codefontsize #1\/}}
\long\def\inlinecodebreak#1{{\codefontsize #1\/}}
\newenvironment{verbatimcode}%
  {\endgraf\codefontsize\verbatim}%
  {\endverbatim}
\newenvironment{ttcode}
  {\codefontsize\begin{alltt}}
  {\end{alltt}}
\def\Di{$D_i$}
\def\Ds{$D_s$}
% From Steve
%\Rule{name}{goals}{conclusions}{sideconditions?}
\newcommand{\Rule}[4]{
\makebox{{\rm #1}
$\displaystyle
\frac{\begin{array}{l}#2\\\end{array}}
{\begin{array}{l}#3\\\end{array}}$
 #4}}


%--------------------------------------------------------
\begin{document}
\bibliographystyle{jfp}

\title[Tutorial]{A Logic System with First-Class Relations
(Draft: January 26, 2004)} \author[Friedman, Kiselyov]
{Daniel P. Friedman
\\ Computer Science Department, Indiana University
\\ Bloomington, IN 47405, USA
\and Oleg Kiselyov
\\ Fleet Numerical Meteorology and Oceanography Center,
\\ Monterey, CA 93943, USA
}
\maketitle

\section{Introduction}
We present an implementation of an embedding in R$^5$
Scheme of a logic system with first-class relations
that we believe interacts smoothly with its host.  How can we have
logic programming and first-class relations and lose nothing of
Scheme?  We make the control structure of logic programming explicit,
so that Scheme programs work with it.  This requires just a small
handful of operations that comprises its interface.

In this introduction we skim over the topics that we cover.  We ask for the
reader's patience when some term or idea is mentioned without a full
explanation.  Keep in mind that we are not only explaining how to write logic
programs, but also how to embed them in Scheme.  All aspects of logic
programming mentioned in this introduction are described later in the paper.
We do assume, however, a reading knowledge of Scheme and some familiarity with
macros.

Logic systems such as Prolog have been around for quite a while and much is
understood about them.  By the way that we have implemented our logic system,
we have been able to include first-class relations.  Furthermore, we make them
extensible, which means that we give ourselves the power of sharing
subrelations.

In order to make this approach work, four properties that are not normally
associated with the discussion of logic programming had to become apparent.
The first property is that most of the time we needn't think about the
relations as a monolithic global relation.  In fact, in most circumstances, the
programmer knows exactly which relation to home in on and we are going to
require that knowledge of the programmer.\footnote{This restriction also
appears in Silvija Seres and Michael Spivey, ``Embedding Prolog in Haskell''.
In \emph{Haskell Workshop}, Paris, France, September, 1999.}  For example, the
relation that infers a type for a programming language differs significantly
from the relation that determines how to concatenate two lists, and both of
these differ considerably from the relation that determines whether two people
are related by the fact that one of them is the father of someone and the other
is the child of that same someone.  Being able to separate these three
relations makes possible a smooth integration with Scheme.

The second property is that there should be no distinction between a Scheme
function and a logic relation.  This has allowed for the removal of a dispatch,
leading to an implementation with \emph{substitution composition} being the
only place where recursion appears.  This is not quite accurate for three
reasons.  First, if only one answer is produced, then no recursion is needed,
but some mechanism must be in place to handle no answer or ask for more answers
(We use streams.).  Second, in order to display answers that contain the same
logic variable (henceforth called variable) more than once, we need a recursive
copier that keeps track of the variables.  But, this is for passing results out
to arbitrary Scheme functions.  Finally, in the last section we introduce pairs
(lists) as valid terms, requiring the revision of several functions, each of
which becomes recursive.

The third property is that gratuitous lists should never be built.  This
matters because we treat relations as finite-arity functions and thus we can
consider the actual arguments separately instead of joined together as a list.
The implications of this decision are far reaching, since it allows us to avoid
many applications of substitutions.  Where there would be two lists to unify,
we now have two sequences of arguments, which means that we can avoid
substituting in each \texttt{cdr} in each list. (See the redefinition of
\texttt{unify*} in the last section.)  Also, if our raw data does not contain
lists, then our unifier does not need to know about them.

The fourth property is that since relations are first-class, they should
support relation contraction and extension operations.  The expansion operation
takes an arbitrary number of relations, all with the same signature.  We start
the development in a more conventional way treating a relation as a single
rule.  Then we present relation extension.  With it, we get the ability to
share relations.

This tutorial has been written so that most definitions come before
their usage.  This has the disadvantage that occasionally the code for
the implementation appears before it is explained.  It has the
advantage, however, that most lines of code can be accounted for while
sitting at a terminal.  This does not necessarily make learning the
material easier, but it does allow the reader to know what parts
belong in what order.  Skimming the tutorial, however, is mostly
discouraged, since some functions and relations are defined multiple
times and their order of definition matters!

There are six additional sections.  First, we include preliminaries,
much of which should be familiar to most readers.  We introduce some
useful syntactic abstractions as well as some standard functions for
dealing with variables, substitutions, and unification.  In section 3
we implement and demonstrate the unsullied logic system.  In section 4
we explore sullied operators, such as those that view the substitution
at any point in a program, and their implementation. Next, we utilize
some recursive relations and include a comparison with an embedding in
Haskell.  We follow that by a section discussing three famous logic
programming problems: \texttt{append}, type inference, and a
generalizaton of Prolog's \texttt{name}.  We conclude with some
perspective on why this approach works.

\section{Preliminaries}

There are four categories of operations we need.  The first category
contains operators for creating lexically-scoped variables
(\texttt{let-lv}), currying (\texttt{lambda@} and \texttt{@}), and a
lexical binder for multiple values (\texttt{let-values}).  The second
category concerns itself with building (\texttt{empty-subst},
\texttt{compose-subst}), pruning (\texttt{prune-subst}), and applying
(\texttt{subst-in}) substitutions.  The third section introduces some
useful functions and macros that return substitutions which
distinguish one variable from another even though they may have been
built with the same name.  The final category has operations for
unifying two terms: \texttt{unify} and \texttt{unify*}.

\subsection{Creating variables, Currying, and a macro for multiple values}

A data structure that may be a variable or contain variables is called
a \emph{term}.  We create a variable using the procedure \texttt{var},
which takes a symbol as its argument. Here is an example of its use.

\begin{alltt}
> (let ([x (var 'x)] [xx (var 'x)])
    (list (var-id x) (var-id xx) (var? x) (eq? x xx)))
(x x #t #f)
\end{alltt}

\noindent
There is a procedure \texttt{var-id} that retrieves the name that a
variable has been built from, there is a predicate \texttt{var?} that
distinguishes variables from other data structures, and each
invocation of \texttt{var} makes a new one.  (We leave the details of
defining these three procedures as an exercise.  Certainly, a uniquely
tagged \texttt{cons} pair with its name in the \texttt{cdr} could be
used, but most Scheme systems have their own record facility.  For
purists, instead of relying on the ability to distinguish two
\texttt{cons} cells with \texttt{eq?}, one could associate a unique
timestamp with each variable.)

We introduce a macro, \texttt{let-lv}, which allows us to both create
variables and have them known within a lexical scope.  Since
we are generating a \texttt{let} expression, it is necessary to
include different names in the first argument to \texttt{let-lv}.

\begin{alltt}
(define-syntax let-lv
  (syntax-rules ()
    [(_ () body) body]
    [(_ () body0 body1 ...) (begin body0 body1 ...)]
    [(_ (id ...) body0 body1 ...)
     (let ([id (var 'id)] ...) body0 body1 ...)]))
\end{alltt}

\noindent
For example,
\begin{alltt}
(let-lv (x y z)
  (list x 1 y 2 z 3))

\end{alltt}

\noindent
expands to (is the same as writing)

\begin{alltt}
(let ([x (var 'x)] [y (var 'y)] [z (var 'z)])
  (list x 1 y 2 z 3))
\end{alltt}

Here is how we can verify these ideas using \texttt{expand} and
\texttt{expand-only}.

\begin{alltt}
> (expand
    '(let-lv (x y z)
       (list x 1 y 2 z 3)))
((lambda (x y z) (list x 1 y 2 z 3))
 (var 'x)
 (var 'y)
 (var 'z))

> (expand-only '(let-lv)
    '(let-lv (x y z)
       (list x 1 y 2 z 3)))
(let ([x (var 'x)] [y (var 'y)] [z (var 'z)])
  (list x 1 y 2 z 3))
\end{alltt}

The macro for \texttt{let-lv} above has three clauses, but only the
last one matters.  The others are there to improve the readability
of the output when \texttt{expand-only} is used.  This may seem, on the
surface, rather foolish, since we know that the full \texttt{expand}
will be invoked, but we do this to improve the readabilty of the
programs expanded by \texttt{expand-only}.  When there is doubt about
how a program works, it is often advantageous to expand a relation
using \texttt{expand-only}.  There are places where we do not use
this approach, primarily because the macros, themselves, get too
complicated.  We restrict this approach to the inclusion of some
simple superfluous clauses as in \texttt{let-lv}.

There are other uses of \texttt{expand-only} below.  The main thing
to observe, however, is that we do not have to expand
\texttt{let} expressions, if we don't want to.  The deeper the nesting
levels of macro calls, the fewer items we might want to place in the
first argument to \texttt{expand-only}.  This one only has two levels:
\texttt{let-lv} expands to \texttt{let}, and \texttt{let} expands to an
application of a \texttt{lambda}-expression.

One other item that we should get familiar with is that using \texttt{list}
works, but misses the structural relationship that we get back using
\texttt{quasiquote} and \texttt{unquote}.  The last example can also be
written like this,

\begin{alltt}
> (expand-only '(let-lv)
    '(let-lv (x y z)
       `(,x 1 ,y 2 ,z 3)))
(let ([x (var 'x)] [y (var 'y)] [z (var 'z)])
  `(,x 1 ,y 2 ,z 3))
\end{alltt}

This way we get Scheme's quasiquote ``\texttt{`}'' and unquote
``\texttt{,}'' to indicate where the variables can be found in a
list structure.  But, as we discover there is still much we can do
with logic programming that does not involve lists.  In fact, they
don't appear until the last section.

\subsubsection{Currying macros}

We also define a curried \texttt{lambda}, \texttt{lambda@},

\begin{alltt}
(define-syntax lambda@
  (syntax-rules ()
    [(_ (formal) body0 body1 ...) (lambda (formal) body0 body1 ...)]
    [(_ (formal0 formal1 formal2 ...) body0 body1 ...)
     (lambda (formal0)
       (lambda@ (formal1 formal2 ...) body0 body1 ...))]))
\end{alltt}

To go along with \texttt{lambda@}, we have \texttt{@}, a curried
application macro.

\begin{alltt}
(define-syntax @
  (syntax-rules ()
    [(_ rator rand) (rator rand)]
    [(_ rator rand0 rand1 rand2 ...) (@ (rator rand0) rand1 rand2 ...)]))
\end{alltt}

\begin{alltt}
> (@ (lambda@ (x y z) (+ x (+ y z))) 1 2 3)
6

> (expand '(@ (lambda@ (x y z) (+ x (+ y z))) 1 2 3))
((((lambda (x)
     (lambda (y)
       (lambda (z)
         (+ x (+ y z)))))
   1) 2) 3)
\end{alltt}

Curried application \texttt{@} and curried \texttt{lambda@} give us
the ability to build and invoke our functions so that the arguments
arrive one at a time.

\subsubsection{A macro for binding multiple return values}

There are times when it is better to be explicit about returning
multiples values.  Here is a simple macro that should encourage
such behavior.

\begin{alltt}
(define-syntax let-values
  (syntax-rules ()
    [(_ (x ...) vs body0 body1 ...)
     (call-with-values
       (lambda () vs)
       (lambda (x ...) body0 body1 ...))]))

> (let-values (x y z) (values 1 2 3)
    (+ x (* y z)))
7
\end{alltt}

Since \texttt{values} is a global function it can be called from
anywhere,
\begin{alltt}
> (= (let ([f (lambda () values)])
       (let-values (x y z) ((f) 1 2 3)
         (+ x (* y z))))
     (let ([f (lambda (w) (values w (+ w 1) (+ w 2)))])
       (let-values (x y z) (f 1)
         (+ x (* y z)))))
#t
\end{alltt}

\subsection{Substitutions}

A substitution, \texttt{s}, is a list of real commitments, represented
using an association list. A \emph{commitment} is a pairing
(\texttt{commitment}) of a variable (\texttt{commitment->var}) to a
term (\texttt{commitment->term}) and it is \emph{real} if its variable
is not the same as its term.  We say a variable is \emph{committed} if
it has an association in a substitution.  We will have occasion to
naively add a commitment to a substitution, so we must be certain that
the commitment is real.

\begin{alltt}
(define cons-if-real-commitment
  (lambda (var term subst)
    (cond
      [(eq? term var) subst]
      [else (cons (commitment var term) subst)])))
\end{alltt}

\noindent
The committed variables (i.e., \texttt{(map commitment->var s)}) of a
substitution must form a set.  We introduce two kinds of
substitutions.  The first is the empty substitution:
\texttt{empty-subst}, which we represent with the empty list.  The
second, built with \texttt{compose-subst}, is formed by refining one
substitution with another to form a new substitution.
\footnote{This material on substitutions is derived from
definitions and examples on pages 18 and 19 of J.\ W.\ Lloyd's
\emph{Foundations of Logic Programming}.}

\begin{alltt}
(define empty-subst '())
\end{alltt}

\begin{alltt}
(define compose-subst
  (lambda (base refining)
    (compose-subst/own-survivors base refining
      (let survive ([r* refining])
        (cond
          [(null? r*) '()]
          [(assq (commitment->var (car r*)) base) (survive (cdr r*))]
          [else (cons (car r*) (survive (cdr r*)))])))))

(define compose-subst/own-survivors
  (lambda (base refining survivors)
    (let refine ([b* base])
      (if (null? b*) survivors
          (cons-if-real-commitment
            (commitment->var (car b*))
            (subst-in (commitment->term (car b*)) refining)
            (refine (cdr b*)))))))
\end{alltt}
When does \texttt{compose-subst} behave like \texttt{append}?  There
are two aspects of the code to consider.  First, the \texttt{assq}
test must always fail.  For if it doesn't, \texttt{survivors}, which
starts out as \texttt{refining} shrinks. Second, the \texttt{subst-in}
expression must not yield a new term the same as
\texttt{(commitment->var (car b*))}.  One way to do this would be to
make sure that the variables of \texttt{(commitment->term (car b*))}
do not overlap with \texttt{(map commitment->var refining)}.

But, of course, \texttt{compose-subst} rarely behaves exactly like
\texttt{append}.  A commitment in the original \texttt{refining}
substitution may not show up in the resultant substitution.  This
happens when a variable is committed in \texttt{base} also is
committed in \texttt{refining}.  This should be obvious, since no
variable can be committed to more than one term in the resultant
substitution.  The one committed in \texttt{base} is the one
that matters.  So composing two substitutions is like taking the union
of the commitments relative to the variables and utilizing the content
of the refining substitution to affect the term in \texttt{base}'s
substitution.  Any resultant unreal commitments are excluded from the
resultant substitution.

\texttt{Exercise a:}
The definition of \texttt{compose-subst} searches the base
substitution multiple times.  It is possible to rewrite the
code so that the each base commitment is looked at once, but
then the refining substitution is search multiple times.
Implement that variant.\endofexercise{}

The procedure \texttt{subst-in} below translates everything to
itself except variables.  If the variable is committed, its associated
term is returned, otherwise the variable itself is returned, since it
is virtually associated with itself. Initially, we restrict terms to
be variables or values that can be trivially compared.  In the last
section we \emph{enlarge the set of terms to include pairs (lists),
which may contain variables.}

\begin{alltt}
(define subst-in
  (lambda (t subst)
    (cond
      [(var? t)
       (cond
         [(assq t subst) => commitment->term]
         [else t])]
      [else t])))
\end{alltt}

\noindent
\texttt{Exercise 1:} Rewrite \texttt{compose-subst} and
\texttt{subst-in} to check in advance to see if any of
its substitution arguments are empty.\endofexercise

In the definition of \texttt{unify*} below we create a
substitution of exactly one real commitment. We make this explicit
with the definition of \texttt{unit-subst} below. The outer
\texttt{list} in the definition is there because every substitution is a
\emph{list} of commitments.

\begin{alltt}
(define unit-subst
  (lambda (var t)
    (list (commitment var t))))
\end{alltt}

Consider the use of substitutions in everyday experiences.  Before you
buy your first motorized vehicle, you have made no commitments to
yourself about its purchase.  You have the empty substitution.  Then
you decide to buy a four-wheeled motorized vehicle.  Now you have
enlarged your empty substitution to include a single commitment that
whatever you buy should have four wheels and an engine.  Then, you
decide to purchase a car.  You have refined your earlier commitment to
buy a truck, a car, or some other four-wheeled vehicle to buying a
car.  You still have only one commitment in your substitution, though
you have composed two nonempty substitutions: the one that stated that
you would buy a four-wheeled motorized vehicle and the one that stated
that you would buy a car.  You can refine your current substitution by
stating that the car would not be over three years old.  You still
have only one commitment.  At some point, you can \emph{also} commit
to purchasing a television.  Now, you have two commitments.  Each time
you refine these two commitments you get a substitution with two
commitments.  For example, you might choose to get a sedan and a color
television.  You still don't know what you are going to get, but as
your current substitution is refined, you are getting closer and
closer to making your decision.  Let's consider some examples:

\begin{alltt}
> (let-lv (x y)
    (equal?
      (compose-subst (unit-subst x y) (unit-subst y 52))
      `(,(commitment x 52) ,(commitment y 52))))
#t

> (let-lv (w x y)
    (equal?
      (let ([s (compose-subst (unit-subst y w) (unit-subst w 52))])
        (compose-subst (unit-subst x y) s))
      `(,(commitment x 52) ,(commitment y 52) ,(commitment w 52))))
#t

> (let-lv (w x y)
    (equal?
      (let ([s (compose-subst (unit-subst w 52) (unit-subst y w))])
        (compose-subst (unit-subst x y) s))
      `(,(commitment x w) ,(commitment w 52) ,(commitment y w))))
#t
\end{alltt}

\begin{alltt}
> (let-lv (w x y)
    (equal?
      (let ([s (compose-subst (unit-subst y w) (unit-subst x y))]
            [r (compose-subst
                 (compose-subst (unit-subst x 'a) (unit-subst y 'b))
                 (unit-subst w y))])
        (compose-subst s r))
      `(,(commitment x 'b) ,(commitment w y))))
#t
\end{alltt}
In the first example, the base substitution commits \texttt{x} to
\texttt{y}.  Then, the refining substitution commits \texttt{y} to
\texttt{52}, refining \texttt{x} to \texttt{52}.  In the second
example, the base substitution of \texttt{s} commits \texttt{y} to
\texttt{w}, refining \texttt{y} to \texttt{52}.  Then \texttt{s} is
used as the refining substitution, so the resultant substitution
commits \texttt{x} to \texttt{52}.  In the third example, the refining
substitution of \texttt{s} does not influence its base.  Thus
\texttt{s} contains the two commitments.  Then the base substitution
of the resultant substitution is refined by the \texttt{y}-commitment committing
\texttt{x} to \texttt{w}.  In the fourth example, we construct two
substitutions manually.  The first contains two commitments and the
second contains three commitments.  The second refines the first to
yield a substitution with only two commitments, since we attempt to
create a commitment of \texttt{y} to \texttt{y}.

\noindent
\texttt{Exercise 2:} Hand trace the fourth example, above, and
thus prove that composing a substitution with two commitments and
a substitution with three commitments can yield a substitution
with just two commitments.\endofexercise

Sometimes we want to prune a substitution relative to some variables.
To do this, we partition the substitution into three substitutions
based on these variables.  We accumulate these three lists by looking
at all the commitments in the full substitution.  If in the process of
partitioning these substitutions, we meet a specific substitution,
\texttt{in-subst}, we know that everything in that substitution will
be clean (i.e., not contain terms that include these variables), so we
can invoke \texttt{compose-subst/own-survivors} with the three
accumulated subsitutions.  The first such substitution finds all the
commitments that must be pruned out.  The second one is all the
commitments that are not going to be affected by the removal of the
variables.  The last substitution contains the commitments that must
be refined.

\begin{alltt}
(define prune-subst
  (lambda (vars in-subst subst)
    (if (eq? subst in-subst)
        subst
        (let loop ([curr subst] [to-remove '()] [clean '()] [to-subst '()])
          (cond
            [(null? curr)
             (compose-subst/own-survivors to-subst to-remove clean)]
            [(eq? curr in-subst)
             (compose-subst/own-survivors to-subst to-remove (append clean curr))]
            [(memq (commitment->var (car curr)) vars)
             (loop (cdr curr) (cons (car curr) to-remove) clean to-subst)]
            [(relatively-ground? (commitment->term (car curr)) vars)
             (loop (cdr curr) to-remove (cons (car curr) clean) to-subst)]
            [else (loop (cdr curr) to-remove clean (cons (car curr) to-subst))])))))

(define ground?
  (lambda (t)
    (cond
      [(var? t) #f]
      [else #t])))

(define relatively-ground?
  (lambda (t vars)
    (cond
      [(var? t) (not (memq t vars))]
      [else #t])))
\end{alltt}

In this pruning, we know that the resultant substitution has the
property that no commitment's variable is in the removed variables,
however, some of the removed variables may still appear in a
commitment's term.

The procedure \texttt{ground?}, although not used here, returns true
if its argument is not a variable.  A term is \emph{ground} if it does
not contain any variables, whatsoever.  The procedure
\texttt{relatively-ground?} returns true if its first argument is a
nonvariable term or if it is a variable, then it is not in
\texttt{vars}. \emph{These two procedures must be redefined when the
set of terms is enlarged.}

\subsection{Concretizing Substitutions}

We introduce a simple function that returns an eye-pleasing
substitution.  In each commitment, we have a variable and a term.  We
need to make sure that even if two variables in the substitution were
constructed from the same name, they must appear as different symbols.
Thus, we introduce the procedure \texttt{artificial-id}.  Normally, a
logic system uses a \texttt{gensym}, but then the results are very
difficult to follow.  So rather than use generated identifiers, we
construct our own artificial ones.

\begin{alltt}
(define artificial-id
  (lambda (var-c)
    (string->symbol
      (string-append
        (symbol->string (var-id (car var-c)))
        "."
        (number->string (cdr var-c))))))

> (let-lv (who) (artificial-id `(,who . 5)))
who.5
\end{alltt}

We associate a unique artificial identifier with each variable.  Each
variable, however, only stores a symbol within it.  Two different
variables could easily have the same symbol within it, so there needs
to be a mechanism to have two different artificial identifiers.  The
way we solve this problem is to use an environment that is both an
input and an output result.  Each item in the environment binds a
variable to a counter.  If the variable is found in the environment,
then the associated artificial identifier is returned.  If it is not
found in the environment, then a second search using
\texttt{assq/var-id} below is attempted.  If a variable built from the
same identifier is in the environment, then a new item is added to the
environment, but its counter is one larger than the previous one. If
these two attempts fail, then the new item added to the envionment
starts the counter at zero.  This is the job of \texttt{concretize-var} below.

\begin{alltt}
(define concretize-var
  (lambda (var env)
    (cond
      [(assq var env)
       => (lambda (var-c) (values (artificial-id var-c) env))]
      [else (let ([var-c `(,var . ,(cond
                                     [(assq/var-id (var-id var) env)
                                      => (lambda (var-c)
                                           (+ (cdr var-c) 1))]
                                     [else 0]))])
              (values (artificial-id var-c) (cons var-c env)))])))
\end{alltt}
\begin{alltt}
(define assq/var-id
  (lambda (id env)
    (cond
      [(null? env) #f]
      [(eq? (var-id (caar env)) id) (car env)]
      [else (assq/var-id id (cdr env))])))
\end{alltt}

\noindent
The only thing to notice about this code is that two items are returned
using \texttt{values} as the result of any call to \texttt{concretize-var}.

Because we are in a logic system, we don't know if we are concretizing
a variable or a trivial constant.  Thus, we use a driver
\texttt{concretize-term}, which dispatches appropriately.  \emph{When we add
pairs as a kind of term, then we need to extend this definition.}

\begin{alltt}
(define concretize-term
  (lambda (t env)
    (cond
      [(var? t) (concretize-var t env)]
      [else (values t env)])))
\end{alltt}

With this technology, it is easy to write a procedure that concretizes
a substitution.

\begin{alltt}
(define concretize-subst
  (letrec
    ([cs (lambda (subst env)
           (cond
             [(null? subst) '()]
             [else
               (let ([comm (car subst)])
                 (let-values (cv env)
                   (concretize-var (commitment->var comm) env)
                   (let-values (ct env)
                     (concretize-term (commitment->term comm) env)
                     (cons (commitment cv ct)
                           (cs (cdr subst)
                           env)))))]))])
    (lambda (subst)
      (cs subst '()))))
\end{alltt}

Here is a somewhat surprising example.

\begin{alltt}
> (concretize-subst
    (compose-subst
      (let-lv (x) (unit-subst x 3))
      (let-lv (x y) (unit-subst x y))))
((x.0 . 3) (x.1 . y.0))
\end{alltt}
If the two \texttt{x}s were the same, then we would have only the
first commitment.  But, since each \texttt{x} is a different variable,
we have two commitments in the concretized substitution.

Finally, we sometimes want to ignore the environment returned as one
of the multiple \texttt{values} from our interface, so we introduce
\texttt{concretize}.

\begin{alltt}
(define concretize
  (lambda (t)
    (let-values (ct new-env) (concretize-term t '())
      ct)))
\end{alltt}

The prinary procedure that we use in this tutorial is
\texttt{concretize-subst}, but occasionally, we use
\texttt{concretize}.

We have one additional interface operator, which allows us to pick
specific variables and their associated terms out of a substitution.
Thus, when we know the small set of variables we are interested in, we
can avoid reconstructing the entire substitution.

\begin{alltt}
(define-syntax concretize-subst/vars
  (syntax-rules ()
    [(_ subst) '()]
    [(_ subst x0 x1 ...)
     (let-values (cx env) (concretize-var x0 '())
       (let-values (ct env) (concretize-term (subst-in x0 subst) env)
         (cons (list cx ct)
           (concretize-subst/vars/env subst env x1 ...))))]))

(define-syntax concretize-subst/vars/env
  (syntax-rules ()
    [(_ subst env) '()]
    [(_ subst env x0 x1 ...)
     (let-values (cv env) (concretize-var x0 env)
       (let-values (ct env) (concretize-term (subst-in x0 subst) env)
         (cons (list cv ct)
           (concretize-subst/vars/env subst env x1 ...))))]))
\end{alltt}

The code is bulky but does not do much.  It uses the same substitution
to determine the concretized substitution whose variables come from
the macro call, itself.  In the second clause of
\texttt{concretize-subst/vars}, it uses the empty environment to get
the process started.

We reiterate what we stated in the beginning of this section.  These
operators are used strictly for building values that work as Scheme
values.  Although it is true that logic variables are Scheme values,
when they are displayed, we cannot tell one logic variable that was
built with the name \texttt{'x} from another logic variable whose
name is also built from \texttt{'x}.  Thus when we see answers, we
must concretize the variables.

\subsection{Unification}

We introduce the unification interface: \texttt{unify} and
\texttt{unify*}.  The interface \texttt{unify} below tries to find a
substitution that will treat the two substituted for terms as equal if
the resultant substitution were applied (using \texttt{subst-in}) to
them.  If successful, it returns a composed substitution.  If it
cannot unify the two terms, then false is returned.  Since we have a
limited definition of term at this time, we can easily write the
auxiliary procedure \texttt{unify*} below.  Two terms unify if they
are the same variable, the same constant term, or one of them is the
\emph{anonymous} variable.  Then, \texttt{unify*} returns the empty
substitution.  That is why we do not choose false to represent the
empty substitution.  Returning the empty substitution means that the
two terms unified.  Of course, that would mean that the two terms
contained no variables or virtually contained no variables.
Otherwise, if either term is a variable, it treats the other as a term
and returns a substitution of a singleton commitment. In all other
cases, the unifier returns false.  (We again stress that these
definitions work until we get to the last section, where we add pairs,
which can contain variables.  When we make this change, we also must
change \texttt{subst-in} to support pairs.

\begin{alltt}
(define _ (let-lv (_) _))

(define unify
  (lambda (t u subst)
    (cond
      [(unify* (subst-in t subst) (subst-in u subst))
       => (lambda (refining-subst)
            (compose-subst subst refining-subst))]
      [else #f])))
\end{alltt}

\begin{alltt}
(define unify*
  (lambda (t u)
    (cond
      [(trivially-equal? t u) empty-subst]
      [(var? t) (unit-subst t u)]
      [(var? u) (unit-subst u t)]
      [else #f])))
\end{alltt}

\begin{alltt}
(define trivially-equal?
  (lambda (t u)
    (or (eqv? t u)
        (eq? t _)
        (eq? u _)
        (and (string? t) (string? u) (string=? t u)))))
\end{alltt}
Here are a few examples.

\begin{alltt}
> (let-lv (x y)
    (and
      (equal? (unify x 3 empty-subst) `(,(commitment x 3)))
      (equal? (unify 4 y empty-subst) `(,(commitment y 4)))
      (equal? (unify x y empty-subst) `(,(commitment x y)))
      (equal? (unify 'x 'x empty-subst) empty-subst)
      (equal? (unify x x empty-subst) empty-subst)
      (not (unify 4 'y empty-subst))
      (not (unify 'x 3 empty-subst))
      (not (unify 3 4 empty-subst))))
#t
\end{alltt}

Only the fifth example is interesting.  It returns the empty
substitution, since the two terms are the same variable.  The sixth
and seventh don't unify because a symbol (not a variable) can never be
equal to a number.

\section{The unsullied logic system}

The logic system has a handful operators: \texttt{relation}
(\texttt{fact} is derived from \texttt{relation}.), which expands into
a \texttt{lambda} expression. We have three macros for handling
sequences of goals: \texttt{all}, its dual \texttt{any}, and its
deterministic counterpart \texttt{all!}.  \texttt{extend-relation},
which gives us the ability to form a new relation from other
relations, is derived from \texttt{any}.  To enter the system, we have
a procedure \texttt{query}, which is used to define \texttt{solve}.
There are two variants of \texttt{extend-relation}:
\texttt{extend-relation-interleave} and
\texttt{extend-relation-interleave/no-overlap}.  Also, there is
\texttt{intersect-relation}, which takes a sequence of relations and
yields their intersection.

Here are the types we use in this system:

\begin{alltt}
                  Fk = () -> Ans
                 Ans = Nil + [Subst, Fk]
                  Sk = Fk -> Subst -> Ans
          Goal = Sk -> Sk
            Relation = Term* -> Goal
\end{alltt}

\texttt{Ans} is a stream of \texttt{Subst}s, since \texttt{Fk} is
a function of zero arguments. An goal is an \texttt{Sk}
transformer.

\subsection{It's a small world}

Let's define a single fact. (Warning: This is not the best time to try
to figure out these definitions.)

\begin{alltt}
(define succeed (lambda@ (sk) sk))

(define-syntax all
  (syntax-rules ()
    [(_) succeed]
    [(_ gl) gl]
    [(_ gl0 gl1 gl2 ...)
     (lambda@ (sk)
       (splice-in-gls/all sk gl0 gl1 gl2 ...))]))

(define-syntax splice-in-gls/all
  (syntax-rules ()
    [(_ sk gl) (@ gl sk)]
    [(_ sk gl0 gl1 gl2 ...)
     (@ gl0 (splice-in-gls/all sk gl1 gl2 ...))]))
\end{alltt}

The \texttt{all} expression has two things in common with Scheme's
\texttt{and} expression.  The second rule is superfluous in both.  Also,
the variant with no arguments is a constant.  With \texttt{and}, it is true
and with \texttt{all}, it is \texttt{succeed}.  Later we discuss the
difference between succeeding and being true.

Let's take a look at how it expands, without worrying about
the actual arguments to \texttt{all}.

\begin{alltt}
> (expand-only '(all splice-in-gls/all lambda@)
    '(all gl1 gl2 gl3 gl4 gl5))
(lambda (sk) (gl1 (gl2 (gl3 (gl4 (gl5 sk))))))
\end{alltt}

\noindent
It looks like the first thing that happens is that \texttt{gl5} is
applied, but although that is the first thing that happens, it is
\texttt{gl1} that actually does the first bit of work.  How is that
possible?  Let's look at a simpler example.

\begin{alltt}
> (expand-only '(all splice-in-gls/all)
    '(all gl1 gl2))
(lambda (sk) (gl1 (gl2 sk)))
\end{alltt}

\noindent
This is just function composition.  We know that \texttt{(gl2 sk)}
must return an \texttt{sk}, since that is what \texttt{gl1} is
expecting.  But suppose that, \texttt{gl1} is also expecting another
argument, say \texttt{fk}. So, we can see this as \texttt{(lambda@ (sk
fk) ((gl1 (gl2 sk)) fk))}.  Now, eventually, if \texttt{gl1}
decides to invoke the \texttt{(gl2 sk)}, which was passed in, it will
do it on a different \texttt{fk}, but it should be clear that
\texttt{gl1} gets to run first.  These two \texttt{lambda}
expressions are $\eta$-convertible, however, so we do not need to
worry about the \texttt{fk}s.  Moreover, there is an additional
argument, \texttt{subst}, that must arrive before \texttt{gl1} runs.
This is tricky, but what is important is that we must understand that
the order of the arguments in \texttt{all} determines when the
goals are run, which is what we would expect.

Next, we consider \texttt{all!}, the more deterministic variant of
\texttt{all}.

\begin{alltt}
(define-syntax promise-one-answer
  (syntax-rules ()
    ((_ gl) gl)))

(define-syntax all!
  (syntax-rules (promise-one-answer)
    [(_) (all)]
    [(_ (promise-one-answer gl)) (promise-one-answer gl)]
    [(_ gl0 gl1 ...)
     (promise-one-answer
       (lambda@ (sk fk)
	 (@
	   (splice-in-gls/all (lambda@ (fk-ign) (@ sk fk)) gl0 gl1 ...)
	   fk)))]))
\end{alltt}

\noindent
And again, we get a feel for what it does by looking at its
expansion.

\begin{alltt}
> (expand-only '(all! splice-in-gls/all)
    '(all! gl1 gl2 gl3))
(promise-one-answer
  (lambda@ (sk fk)
    (@ (@ gl1
         (@ gl2
           (@ gl3
             (lambda@ (fk-ign)
               (@ sk fk)))))
       fk)))
\end{alltt}

As in the previous version, if all goals succeed, then the
original success continuation \texttt{sk} is invoked.  But, this time,
however, once \texttt{gl3} succeeds, if failure backs into it, it
invokes the original failure continuation, rather than retry
\texttt{gl3}.  That is, the \texttt{all!} expression fails. This is
what is meant by ``promise one answer''.

Finally, we introduce the fully deterministic \texttt{all!!}.

\begin{alltt}
(define-syntax all!!
  (syntax-rules ()
    [(_) (all!)]
    [(_ gl) (all! gl)]
    [(_ gl0 gl1 ...)
     (promise-one-answer
       (lambda@ (sk fk)
         (splice-in-gls/all!! sk fk gl0 gl1 ...)))]))

(define-syntax splice-in-gls/all!!
  (syntax-rules (promise-one-answer)
    [(_ sk fk) (@ sk fk)]
    [(_ sk fk (promise-one-answer gl)) (@ gl sk fk)]
    [(_ sk fk gl0 gl1 ...)
     (@ gl0
       (lambda (fk-ign)
         (splice-in-gls/all!! sk fk gl1 ...))
       fk)]))
\end{alltt}

Again, it should be easier to follow a specific instance of its use.

\begin{alltt}
(promise-one-answer
  (lambda@ (sk fk)
    (@ gl1
      (lambda (fk-ign)
        (@ gl2
          (lambda (fk-ign)
            (@ gl3
              (lambda (fk-ign)
                (@ sk fk))
              fk))
          fk))
      fk)))
\end{alltt}

The macro \texttt{all!!} generates a procedure that expects a success
and a failure continuation (and one more, which is $\eta$-reduced
away).  Each goal is run in a new success continuation, but each
is run with the same failure continuation.  Thus, this is a fully
deterministic \texttt{all}.  One slip up, and you fail, whereas, with
\texttt{all}, you get to backup through the goals and retry them
until success, but we are getting a bit ahead of our story.

Even with all this technology to explain the idea of using all, all!,
and all!!, it is still possible that some confusion remains.  So, we
shall look at three simple examples that should clarify how these
work together.

Let us assume that \texttt{a}, \texttt{b}, \texttt{c} \texttt{d},
\texttt{e} and \texttt{f} are all goals.  Then consider these
three goals

\begin{alltt}
1. (all a b (all c d) e f)

2. (all a b (all! c d) e f)

3. (all a b (all!! c d) e f)
\end{alltt}

Of course, the only place they differ is in their third goal.
The first example is the same as \texttt{(all a b c d e f)}.  Thus, if
\texttt{b} fails, it retries \texttt{a}, if \texttt{c} fails, it
retries \texttt{b}, etc. But, most importantly for our second and
third examples, if \texttt{e} fails, it retries \texttt{d}.  In the
second example, if \texttt{e} fails, then it retries \texttt{(all! c
d)}, which forces a retry of \texttt{b}.  If \texttt{d} fails, it
retries \texttt{c}.  The last example is the same as the second
example, but if \texttt{d} fails, it retries \texttt{b}, since within
\texttt{(all!! c d)} if any goal fails, it retries \texttt{b}.
This follows from the fact that any failure causes the entire
\texttt{(all!! c d)} goal to fail.  In each of the three
examples, if \texttt{c} fails, then it retries \texttt{b}.

The macro \texttt{exists} makes sure that the variables
lexically introduced by \texttt{let-lv} are no longer in the
domain of the any substitution when the variables go out of scope.
Of course, this does not mean that these variables vanish completely
from the substitution, since they may be part of some commitment's term.

\begin{alltt}
(define-syntax exists
  (syntax-rules ()
    [(_ () gl) gl]
    [(_ (id0 id1 ...) gl)
     (let-lv (id ...)
       (lambda@ (sk fk in-subst)
	 (@ gl
            (lambda@ (fk out-subst)
              (@ sk fk (prune-subst (list id0 id1 ...) in-subst out-subst)))
            fk
            in-subst)))]))
\end{alltt}

We need one more useful macro, \texttt{==}.  It takes two terms and
unifies them with an existing substitution, yielding a new
substitution if the unification succeeds, otherwise it invokes the
existing failure continuation.  The \texttt{lambda@} pulls in the
state of the computation that is sitting in its three variables.

\begin{alltt}
(define-syntax ==
  (syntax-rules ()
    [(_ t u)
     (lambda@ (sk fk subst)
       (cond
         [(unify t u subst)
          => (lambda (subst)
               (@ sk fk subst))]
         [else (fk)]))])))
\end{alltt}

Finally, we come to \texttt{relation} below, which is like a special
\texttt{lambda}.  There are three clauses to consider.  The first and
second conspire to get to the third clause.  They do that by using the
exact match of the \texttt{to-show} keyword, which then sets up a loop
accumulating fresh variables the length of the arguments to the
\texttt{to-show} keyword.  Once the accumulation has been accomplished
in the \texttt{(g ...)}, we consider the remaining clause.  The
\texttt{all!!} of the unifications is wrapped by an \texttt{all} and
is followed by the goals.  Thus, if all the unifications succeed
yielding a substitution, we start with that resultant substitution and
try to show the goals.

\begin{alltt}
(define-syntax relation
  (syntax-rules (to-show)
    [(_ (ex-id ...) (to-show x ...) gl ...)
     (relation (ex-id ...) () (x ...) (x ...) gl ...)]
    [(_ (ex-id ...) (var ...) (x0 x1 ...) xs gl ...)
     (relation (ex-id ...) (var ... g) (x1 ...) xs gl ...)]
    [(_ (ex-id ...) (g ...) () (x ...) gl ...)
     (lambda (g ...)
       (exists (ex-id ...)
         (all (all!! (promise-one-answer (== g x)) ...) gl ...)))]))
\end{alltt}

There are several special cases that we can observe from the last
clause of \texttt{relation}.  The \texttt{g}s might be empty, and the
\texttt{gl}s might be empty.  In addtion, there might be exactly one
\texttt{gl}.  Thus we revise \texttt{relation} to check for these
special cases.

\begin{alltt}
(define-syntax relation
  (syntax-rules (to-show)
    [(_ (ex-id ...) (to-show x ...) gl ...)
     (relation (ex-id ...) () (x ...) (x ...) gl ...)]
    [(_ (ex-id ...) (var ...) (x0 x1 ...) xs gl ...)
     (relation (ex-id ...) (var ... g) (x1 ...) xs gl ...)]
    [(_ (ex-id ...) () () () gl ...)
     (lambda ()
       (exists (ex-id ...)
         (all gl ...)))]
    [(_ (ex-id ...) (g ...) () (x ...))
     (lambda (g ...)
       (exists (ex-id ...)
 	 (all!! (promise-one-answer (== g x)) ...)))]
    [(_ (ex-id ...) (g ...) () (x ...) gl)
     (lambda (g ...)
       (exists (ex-id ...)
 	 (if-all! ((promise-one-answer (== g x)) ...) gl)))]
    [(_ (ex-id ...) (g ...) () (x ...) gl ...)
     (lambda (g ...)
       (exists (ex-id ...)
         (all (all!! (promise-one-answer (== g x)) ...) gl ...)))]))
\end{alltt}

We now have enough tools to define a relation with a single fact.
Our relation says that ``Rob is the father of Sal.''

\begin{alltt}
(define father
  (relation ()
    (to-show 'rob 'sal)))
\end{alltt}

Let's focus on the single fact that says that ``Rob is the father of
Sal.''  But, what it really says is that there is a relation, that
connects ``Rob to Sal,'' which we are calling ``The father relation.''
And when do we know that Rob is the father of Sal?  When we have shown
that all the goal expressions below the \texttt{to-show} keyword
expression hold.  But, since there are none, it holds vacuously.
Therefore, Rob is always the father of Sal.  But, if we have another
relation, \emph{older\_than}, we can have the fact that ``Rob is older
than Sal.''  The only thing that would change is that we would replace
the variable \texttt{father} by \texttt{older-than}.  This is a lot
deeper than it may first appear.  Our relations are first class.  If
we want to do the same thing, we could also just \texttt{(define
older-than father)}, which would say that ``Rob is older than Sal.''
Of course, that should not come as a surprise, since Rob is Sal's
father, but these two relations are completely disjoint!  For example,
we may be referring to four different people: two Robs and two Sals.

Sometimes the list of variable identifiers that follows
\texttt{relation} is nonempty, but don't be confused: \emph{This list
does not tell how many arguments the relation takes. That is
determined by the number of terms following the keyword}
\texttt{to-show}.

Consider the partial expansion of \texttt{father}
\begin{alltt}
> (expand-only '(relation exists)
    '(define father
       (relation ()
         (to-show 'rob 'sal))))
(define father
  (lambda (g1 g2)
    (all!!
      (promise-one-answer (== g1 'rob))
      (promise-one-answer (== g2 'sal)))))
\end{alltt}

The relation \texttt{father} is represented as a procedure of two
arguments, \texttt{g1} and \texttt{g2}.\footnote{The actual expansion
produces \texttt{g} and \texttt{g}.  But, they are different
variables.} It can figure that out from the number of operands in the
\texttt{to-show} keyword expression.  If we can unify the value of the
variable \texttt{g1} with the value of \texttt{'rob} and the value of
the variable \texttt{g2} with the value of \texttt{'sal}, then the
resultant substitution is passed to a procedure that addresses any
remaining goals.  In our simple example, there are none.

Whenever \texttt{father} is invoked, a dad (\texttt{g1}) and a child
(\texttt{g2}) get bound to a term.  Then an goal is returned.
This goal is waiting for a success continuation, a failure
continuation, and a substitution.  The failure continuation is invoked
if the arguments fail to unify.  This causes a return from the call
to \texttt{father}, since \texttt{all!!} fails if any of its arguments
fail.

There is a relation between \texttt{relation} and goals.
It is possible to turn any antededent into a zero-argument
relation using \texttt{gl->relation} below.

\begin{alltt}
(define gl->relation
  (lambda (gl)
    (relation () (to-show) gl)))
\end{alltt}

Next, we define a relation \texttt{child-of-male} and compare its expansion
to the previous relation.

\begin{alltt}
(define child-of-male
  (relation (child dad)
    (to-show child dad)
    (father dad child)))
\end{alltt}

Such a relation is often written using a horizontal line,
\Rule{}{\texttt{(father dad child)}} {\texttt{(child-of-male child dad)}}{}

\begin{alltt}
> (expand-only '(relation)
    '(define child-of-male
       (relation (child dad)
         (to-show child dad)
         (father dad child))))
(define child-of-male
  (lambda (g g)
    (exists (child dad)
      (all (all!!
             (promise-one-answer (== g child))
             (promise-one-answer (== g dad)))
           (father dad child)))))
\end{alltt}

We can see that to show that some person (\texttt{child}) is the child
of a male (\texttt{dad}), all we have to show is that \texttt{dad} is the
father of \texttt{child}.  This is very naive but logical
reasoning.\footnote{Use the partially-expanded variant of
\texttt{child-of-male} instead of the unexpanded \texttt{relation} to
install a \texttt{let} expression around the \texttt{exists}
expression.  For example, one might want to read from a file, print
what was read, and then unify against it instead of against
\texttt{child}.}

Closer inspection of \texttt{child-of-male} is available by also
expanding \texttt{exists}.

\begin{alltt}
(define child-of-male
  (lambda (g1 g2)
    (let-lv (child dad)
      (lambda@ (sk fk in-subst)
        (@ (lambda@ (sk)
             (@ (all!!
                  (promise-one-answer (== g1 child))
                  (promise-one-answer (== g2 dad)))
                (@ (father dad child) sk)))
           (lambda@ (fk out-subst)
             (@ sk fk (prune-subst (list child dad) in-subst out-subst)))
           fk
           in-subst)))))
\end{alltt}

Here, we see that the body of \texttt{let-lv} is an goal, which
runs the \texttt{all!!} expression with a success continuation that
will prune away the naively introduced variables \texttt{child} and
\texttt{dad} from the resultant substitution.  The substitution
\texttt{in-subst} if reached while pruning cannot contain terms with
\texttt{child} or \texttt{dad}, so it acts as a stopping point if it
is reached.  Thus when the variables introduced with this use of
\texttt{let-lv} go out of scope, they also disappear from the
\emph{domain}, but not necessarily the \emph{range} of the resultant
substitution.

\noindent
\texttt{Exercise 3:} How does this expanded definition differ if we
also expand this code with respect to \texttt{all!!}?\endofexercise

\subsection{Testing \texttt{father} and \texttt{child-of-male}}

We are now ready to test \texttt{father}.  For example, we might wish
to determine ``If Rob is the father of Sal.''

\begin{alltt}
(define initial-sk (lambda@ (fk subst) (cons subst fk)))
(define initial-fk (lambda () '()))

> (let ([gl (father 'rob 'sal)])
    (@ gl initial-sk initial-fk empty-subst))
(() . #<initial-fk>)
\end{alltt}

If the goal succeeds by invoking \texttt{initial-sk} on a substitution
and a failure continuation, then once it gets the failure
continuation, it returns a pair of the substitution and a failure
continuation. If the goal fails, the empty list, the result of
invoking \texttt{initial-fk}, is returned.

Since our test has no variables, we know that we do not refine the
original substitution, but unify when the raw values in each term are
the same.  What is the purpose of the empty substitution, \texttt{()}?
At this point, we can (using \texttt{subst-in}) apply the empty
substitution to each term in the original term and produce what we
started with: \texttt{(rob sal)}, but with the assurance that
\texttt{rob} has been shown to be the father of \texttt{sal}.

We abstract the previous test using the function, \texttt{query}
below.

\begin{alltt}
(define query
  (lambda (gl)
    (@ gl initial-sk initial-fk empty-subst)))
\end{alltt}

We next consider the role of nonempty substitutions.  Instead of
asking a specific question about Rob's relationship to Sal, let's
determine a child of Rob.  To do this, we introduce a variable.

\begin{alltt}
> (let-lv (x)
    (let ([result (query (father 'rob x))])
      (and
        (equal? (car result) `(,(commitment x 'sal)))
        (null? ((cdr result))))))
#t
\end{alltt}

We can test \texttt{child-of-male} the same way, but this time we
choose to give it no raw data, just variables, and hope that a
nonempty substitution, the \texttt{car} of the result of the query, is
returned.

\begin{alltt}
> (let-lv (x y)
    (let ([result (query (child-of-male x y))])
      (let ([subst (car result)])
        (concretize-subst/vars subst x y))))
((x.0 sal) (y.0 rob))
\end{alltt}

And, we discover that Sal is the child of Rob.

\subsection{Generating more than one answer}

The difference between a relation and a function is that with a
function, only one answer is associated with an input, but with a
relation the same input can lead to many answers.  Now, we demonstrate
in what ways functions such as the definition of \texttt{father}
below can be treated as relations.

Suppose that Rob is also the father of Pat, what changes could be
made to get both answers?  First, we introduce
\texttt{extend-relation} to allow for additional facts.

The operator \texttt{any} is the dual of \texttt{all}.

\begin{alltt}
(define fail
  (lambda@ (sk fk subst)
    (fk)))

(define-syntax any
  (syntax-rules ()
    [(_) fail]
    [(_ gl) gl]
    [(_ gl ...)
      (lambda@ (sk fk subst)
	(splice-in-gls/any sk fk subst gl ...))]))

(define-syntax splice-in-gls/any
  (syntax-rules ()
    [(_ sk fk subst gl) (@ gl sk fk subst)]
    [(_ sk fk subst gl0 gl1 gl2 ...)
     (@ gl0
        sk
        (lambda ()
          (splice-in-gls/any sk fk subst gl1 gl2 ...))
       subst)]))
\end{alltt}

The first two clauses are simple.  The first, is the dual of
\texttt{all}, since when there are no goals for \texttt{all},
we \texttt{succeed}, whereas with \texttt{any} when we have no
goals, we \texttt{fail}.  As before, just one goal, expands
to that one goal.  So, let's see what happens when we have more
than one goal.

\begin{alltt}
> (expand-only '(any splice-in-gls/any)
    '(any gl1 gl2))
(lambda@ (sk fk subst)
  (@ gl1
     sk
     (lambda ()
       (@ gl2 sk fk subst))
     subst))
\end{alltt}

\noindent
and

\begin{alltt}
> (expand-only '(any splice-in-gls/any)
    '(any gl1 gl2 gl3))
(lambda@ (sk fk subst)
  (@ gl1
     sk
     (lambda ()
       (@ gl2
          sk
          (lambda ()
            (@ gl3 sk fk subst))
          subst))
     subst))
\end{alltt}
\noindent
Each failure continuation starts with the same success continuation
and the same substitution.

Now, we are able to build a single relation from a sequence of relations.

\begin{alltt}
(define-syntax extend-relation
  (syntax-rules ()
    [(_ (id ...) rel-exp ...)
     (extend-relation-aux (id ...) () rel-exp ...)]))

(define-syntax extend-relation-aux
  (syntax-rules ()
    [(_ (id ...) ([g rel-exp] ...))
     (let ([g rel-exp] ...)
       (lambda (id ...)
         (any (g id ...) ...)))]
    [(_ (id ...) (let-pair ...) rel-exp0 rel-exp1 ...)
     (extend-relation-aux (id ...)
       (let-pair ... [g rel-exp0]) rel-exp1 ...)]))
\end{alltt}

For each relation expression, we generate a \texttt{let} expression
pair that holds the value of the relation expression.  Then, a
hand-bulit relation of the right number of arguments is built, with
\texttt{any} wrapped around all the relation calls.

\begin{alltt}
(define rob-pat
  (relation ()
    (to-show 'rob 'pat)))
\end{alltt}

Now, we have two relations.  What we want to do is combine the two
relations into a single one.

\begin{alltt}
(define father (extend-relation (a1 a2) father rob-pat))
\end{alltt}

The operator \texttt{extend-relation} takes a list of \texttt{lambda}
variables, the length of which is the arity of the relation, and a
sequence of relations. In the convention we use, the \emph{i} in the
last \texttt{a}\emph{i} in the list is the arity (In \texttt{father},
it is 2.) of the relations.  It tries to find a result in the first
relation. If it succeeds, it returns a substitution along with a
failure continuation, which is to try to find a result in the
remaining relations.  If it fails, then it invokes the just described
failure continuation.  The early evaluation of the relation
expressions is critical in order to guarantee that we can write
expressions such as \texttt{(define x (extend-relation (a1 a2) x y))}.
Without this early evaluation, the original relation \texttt{x} would
not be part of the new definition of \texttt{x}, which would lead to
an infinite loop.\footnote{This is an argument for making
\texttt{extend-relation} a procedure, but then it would be necessary
to use \texttt{(lambda args ...)} and \texttt{apply}, which we believe
should be avoided, when possible.}  Later, we present other variants of
\texttt{extend-relation}.

Let's see how this new definition of \texttt{father} expands.

\begin{alltt}
> (expand-only '(extend-relation extend-relation-aux)
    '(define father (extend-relation (a1 a2) father rob-pat)))
(define father
  (let ([g1 father] [g2 rob-pat])
    (lambda (a1 a2)
      (any (g1 a1 a2) (g2 a1 a2)))))
\end{alltt}
\noindent
What is critical here is that we get a kind of call-by-value behavior,
since the relation arguments, \texttt{father} and \texttt{rob-rel}, to
\texttt{extend-relation}, are evaluated (in this case just
dereferenced) before the extended relation is returned.  Also the
arguments to \texttt{any} involve applications of the generated
((\texttt{g}\emph{i}) variables passing along the artificial
(\texttt{a}\emph{i}) variables.

A convenient abbreviation of a relation where there are no goals
is decribed by the macro \texttt{fact}.

\begin{alltt}
(define-syntax fact
  (syntax-rules ()
    [(_ (ex-id ...) x ...) (relation (ex-id ...) (to-show x ...))]))
\end{alltt}

Then we could write the \texttt{father} relation like this.

\begin{alltt}
(define father
  (extend-relation (a1 a2)
    (fact () 'rob 'sal)
    (fact () 'rob 'pat)))
\end{alltt}

\noindent
and test it like this.

\begin{alltt}
> (let ([answer (query (father 'rob x))])
    (let ([subst (car answer)])
      (cons
        (concretize-subst/vars subst x)
        (let ([answer ((cdr answer))])
          (let ([subst (car answer)])
            (cons
              (concretize-subst/vars subst x)
              (let ([answer ((cdr answer))])
                (if (null? answer)
                  '()
                  (let ([subst (car answer)])
                    (cons
                      (concretize-subst/vars subst x)
                      '()))))))))))
((x.0 sal)
 (x.0 pat))
\end{alltt}
\noindent
First, we add that Rob is also the father of Pat.  Then, when we
invoke \texttt{fk} (i.e., invoke the thunk returned from \texttt{(cdr
answer)}) the first time, we get another result.  When we invoke it a
second time, we are out of results, so we get back the empty list, the
result of invoking the initial failure continuation.

\subsection{Streams (infinite lists) provide a natural interface}

We would like to abstract the previous program in a more coherent way.
Later, we see an example where there is no limit on the number of
answers, but if we want to process the answers as a list, we must
place some bound on the size of the list.

The \texttt{(car answer)} is a substitution, and the \texttt{(cdr
answer)} is a thunk that if invoked returns a value whose \texttt{car}i
is a substitution, and whose \texttt{cdr} is a thunk, etc.  This is a
stream (possibly infinite list) of such pairs.  We write the function,
\texttt{stream-prefix}, which given a bound \texttt{n}, and a stream,
\texttt{strm}, yields a list with at most one element, if \texttt{n}
is 0; at most two elements, if \texttt{n} is 1; etc.  But, we must be
careful that going for the \texttt{n+1}st element of a stream does not
lead to an infinite loop, even though we only want the first
\texttt{n} elements! This causes \texttt{stream-prefix} to be written
in a slightly awkward fashion.

\begin{alltt}
(define stream-prefix
  (lambda (n strm)
    (if (null? strm) '()
      (cons (car strm)
        (if (zero? n) '()
          (stream-prefix (- n 1) ((cdr strm))))))))
\end{alltt}

Let us return to our discussion about how we are going to use
\texttt{stream-prefix}.  Once we have a finite list of substitutions,
we are free to use them however we wish. For example, we define a
macro \texttt{solve} that takes a positive integer upper bound, a list
of variable names, and an goal (here a relation call).  It
returns a list like the one above for Rob's children.  Each variable
is associated with the substituted for term of its commitment.

\begin{alltt}
(define-syntax solve
  (syntax-rules ()
    [(_ n (var ...) gl)
     (let-lv (var ...)
       (map (lambda (subst)
              (concretize-subst/vars subst var ...))
         (stream-prefix (- n 1) (query gl))))]))
\end{alltt}

\begin{alltt}
> (solve 5 (x) (father 'rob x))
(((x.0 sal))
 ((x.0 pat)))
\end{alltt}

\noindent
Of course, the resultant list contains only two answers, but
asking for five does no harm, since it quits early when the
\texttt{null?} test in \texttt{stream-prefix} holds.

Let's see what this call partially expands to.
\begin{alltt}
> (expand-only '(solve)
    '(solve 5 (x) (father 'rob x)))
(let-lv (x)
  (map
    (lambda (subst)
      (concretize-subst/vars subst x))
    (stream-prefix (- 5 1) (query (father 'rob x)))))
\end{alltt}

\noindent
\texttt{Exercise 4:} Redefine \texttt{solve} to set up an interactive
loop to force more answers.  Use \texttt{0} to indicate no more
answers and use \texttt{+} to indicate more answers.\endofexercise

We can simplify things a bit when we want at most one result with
\texttt{solution},

\begin{alltt}
(define-syntax solution
  (syntax-rules ()
    [(_ (var ...) gl)
     (let ([ls (solve 1 (var ...) gl)])
       (if (null? ls) #f (car ls)))]))
\end{alltt}

\begin{alltt}
> (solution (x) (father 'rob x))
((x.0 sal))
\end{alltt}

\noindent
\texttt{Exercise 5:} Rewrite \texttt{solution} by redefining
\texttt{initial-sk} and \texttt{initial-fk}.\endofexercise

Using \texttt{stream-prefix} meets our needs for this tutorial, but in
general, it may be too naive.  We may want all the answers until some
predicate holds about one or more of the answers.  For example, the
result might be a stream of integers that terminates after the third odd
integer appears.  In this case, it is impossible to know what integer bound
to pass to \texttt{stream-prefix}.  In those circumstances, it is best
to process the stream of substitutions using a hand-crafted procedure.

\subsection{Sequences of goals}

In the definition of \texttt{child-of-male}, we have exactly one
goal.  We are going to look at relations with additional
goals.

Let's first redefine \texttt{father}.

\begin{alltt}
(define father
  (extend-relation (a1 a2)
    (fact () 'jon 'sam)
    (fact () 'sam 'rob)
    (fact () 'rob 'sal)
    (fact () 'rob 'pat)))
\end{alltt}

So, we see that Sam is the grandfather of Sal and Pat, and Jon is the
grandfather of Rob.  We might ask, ``Is Sam the grandfather of anyone
in our closed five-person world?''

\begin{alltt}
(define grandpa-sam
  (relation (grandchild)
    (to-show grandchild)
    (exists (parent)
      (all (father 'sam parent) (father parent grandchild)))))
\end{alltt}

\begin{alltt}
> (solve 6 (y) (grandpa-sam y))
(((y.0 sal))
 ((y.0 pat)))
\end{alltt}

It is correct, because Sam is the father of Rob, and Rob is the
father of Sal and Pat.  Here is how the substitutions that led to this
answer were built.  First the variable bound to \texttt{y} became some
\texttt{grandchild}.  At this point, \texttt{y} is not instantiated,
only \emph{shared} with the variable \texttt{grandchild}.  Then
\texttt{parent} is instantiated to Rob.  Next, \texttt{grandchild} is
instantiated to Sal, but we know that \texttt{y} is shared with
\texttt{grandchild}, so \texttt{y} is also instantiated to Sal.  Then
we fail, thus re-instantiating \texttt{grandchild} to Pat.  Finally,
the failures back all the way out, leading to the empty list (the
result of invoking \texttt{initial-fk}).

The implementation of the basic unsullied logic system is now
complete.  Most of what we may want to do with a logic system can be
programmed with this basic system comprised of \texttt{relation} (and
\texttt{fact}), \texttt{any} (and \texttt{extend-relation}),
\texttt{all}, \texttt{all!}, \texttt{all!!}, and \texttt{solve}.

Let's return (using \texttt{all}) to the most recent definition of
\texttt{grandpa-sam}.  Obviously this is not as general as we might
expect.  Consider an attempt to take us beyond concerns for Sam.

\begin{alltt}
(define grandpa-maker
  (lambda (grandad)
    (relation (grandchild)
      (to-show grandchild)
      (exists (parent)
        (all (father grandad parent) (father parent grandchild))))))

> (solve 6 (x) ((grandpa-maker 'sam) x))
(((x.0 sal))
 ((x.0 pat)))
\end{alltt}

\noindent
This just uses lexical scope to reconstruct \texttt{grandpa-sam}.
But, it still requires that we know who we want to find out about. We
do something a bit more abstract below.  We postpone the
determination of the function \texttt{guide} by making it, too, a
variable. Here it is lexical, but it can be a logic variable, instead,
because procedures are treated as raw values.  Thus, we can pass the function
\texttt{father}, which then gets invoked.  This allows for the
potential creation of a more abstract relation.  For example, if we
had a \texttt{mother} definition, like our \texttt{father} definition,
then \texttt{grandpa-maker} would still work, as long as
\texttt{mother} is passed to \texttt{grandpa-maker} instead of
\texttt{father}.  Then we would have a matrilineal grandparent instead
of a patrilineal one.  Of course, then ``\texttt{grandpa-maker}'' and
``\texttt{grandad}'' would be poorly chosen names.

\begin{alltt}
(define grandpa-maker
  (lambda (guide grandad)
    (relation (grandchild)
      (to-show grandchild)
      (exists (parent)
        (all (guide grandad parent) (guide parent grandchild))))))

> (solve 4 (x) ((grandpa-maker father 'sam) x))
(((x.0 sal))
 ((x.0 pat)))
\end{alltt}

Next we consider a more concrete problem, which is to use our logic
system to define \texttt{grandpa}.  Now, we can replace the lexical
variable \texttt{grandad} with the logic variable \texttt{grandad},
which leaves the decision completely open.

Here is our first (somewhat naive) definition of \texttt{grandpa}.

\begin{alltt}
(define grandpa
  (relation (grandad grandchild)
    (to-show grandad grandchild)
    (exists (parent)
      (all (father grandad parent) (father parent grandchild)))))

> (solve 4 (x) (grandpa 'sam x))
(((x.0 sal))
 ((x.0 pat)))
\end{alltt}

We make Rob an uncle of Sue and Sid, the children of his sister,
Roz.  First, we include Roz in the \texttt{father} relation.
Then, we define a \texttt{mother} relation, including some facts like
we did for the \texttt{father} relation.  Finally, we add a relation
to the \texttt{grandpa} relation, so that Rob's sister's children can
claim Sam as their grandfather.

\begin{alltt}
(define sam-roz (fact () 'sam 'roz))
(define father (extend-relation (a1 a2) father sam-roz))
\end{alltt}

\begin{alltt}
(define roz-sue (fact () 'roz 'sue))
(define roz-sid (fact () 'roz 'sid))
(define mother (extend-relation (a1 a2) roz-sue roz-sid))
\end{alltt}

\begin{alltt}
(define grandpa
  (extend-relation (a1 a2) grandpa
    (relation (grandad grandchild)
      (to-show grandad grandchild)
      (exists (parent)
        (all (father grandad parent) (mother parent grandchild))))))
\end{alltt}

\begin{alltt}
> (solve 10 (y) (grandpa 'sam y))
(((y.0 sal))
 ((y.0 pat))
 ((y.0 sue))
 ((y.0 sid)))
\end{alltt}

\noindent
And we discover that Sam is, indeed, the grandfather of
Sue and Sid.

\subsection{Sharing}
In the previous definition of \texttt{grandpa}, both relations use the
same \texttt{to-show}, so why should we write them twice?
\begin{alltt}
(define grandpa
  (extend-relation (a1 a2)
    (relation (grandad grandchild)
      (to-show grandad grandchild)
      (exists (parent)
        (all (father grandad parent) (father parent grandchild))))
    (relation (grandad grandchild)
      (to-show grandad grandchild)
      (exists (parent)
        (all (father grandad parent) (mother parent grandchild))))))
\end{alltt}

Instead, we can write it with \texttt{any} like this.

\begin{alltt}
(define grandpa
  (relation (grandad grandchild)
    (to-show grandad grandchild)
    (exists (parent)
      (any
        (all (father grandad parent) (father parent grandchild))
        (all (father grandad parent) (mother parent grandchild))))))
\end{alltt}

And we can distribute \texttt{any}, since in both cases we are
invoking the relation call \texttt{(father grandad parent)}
\begin{alltt}
(define grandpa
  (relation (grandad grandchild)
    (to-show grandad grandchild)
    (exists (parent)
      (all (father grandad parent)
           (any (father parent grandchild)
                (mother parent grandchild))))))
\end{alltt}

\noindent
\texttt{Exercise 8:} Suppose that the keyword \texttt{to-show} were
restricted to take a single argument.  Here is an example to study
where \texttt{grandpa-sam} has the right structure for thinking
about such arcane problems.

\begin{alltt}
(define grandpa-sam
  (let ([r (relation (child)
             (to-show child)
             (exists (parent)
               (all (father 'sam parent) (father parent child))))])
    (relation (child)
      (to-show child)
      (r child))))
\end{alltt}
Rewrite some variant of \texttt{grandpa} with that restriction.\endofexercise

We return to the issue of extending relations.  We mentioned earlier
that we would perhaps want to combine two relations in a different
way.  Under what circumstances might this come up?  Since we are free
to think about each relation as returning a stream of results, we can
envisage a scenario where the first stream is unbounded.  Then no
results will arrive from the second stream.  We can avoid this problem
by combining two relations using \texttt{binary-extend-relation-interleave}.

\begin{alltt}
(define-syntax binary-extend-relation-interleave
  (syntax-rules ()
    [(_ (id ...) rel-exp1 rel-exp2)
     (let ([rel1 rel-exp1] [rel2 rel-exp2])
       (lambda (id ...)
         (lambda@ (sk fk subst)
           ((interleave sk fk (finish-interleave sk fk))
            (@ (rel1 id ...) initial-sk initial-fk subst)
            (@ (rel2 id ...) initial-sk initial-fk subst)))))]))

(define finish-interleave
  (lambda (sk fk)
    (letrec
      ([finish
         (lambda (q)
           (cond
             [(null? q) (fk)]
             [else (let ([fk (cdr q)] [subst (car q)])
                     (@ sk (lambda () (finish (fk))) subst))]))])
      finish)))

(define interleave
  (lambda (sk fk finish)
    (letrec
      ([interleave
         (lambda (q1 q2)
           (cond
             [(null? q1) (if (null? q2) (fk) (finish q2))]
             [else (let ([fk (cdr q1)] [subst (car q1)])
                     (@ sk (lambda () (interleave q2 (fk))) subst))]))])
      interleave)))
\end{alltt}

The interesting part of this code takes place in \texttt{interleave}.
There, it takes turns absorbing a result from one stream and then from
the other.  Once it has exhausted one of the streams, it
\texttt{finish}es the job on the other one.  The success and failure
continuations that are passed into \texttt{interleave} and
\texttt{finish-interleave} from the start are the ones that came in as
part of the invocation of an goal.  But, when the actual
goal gets passed arguments, it uses the \emph{initial} success
and failure continuations.

\noindent
\texttt{Exercise 9:} Implement \texttt{extend-relation-interleave},
which takes an arbitrary number of relations.\endofexercise

What other variant is possible?

\begin{alltt}
(define-syntax binary-extend-relation-interleave-non-overlap
  (syntax-rules ()
    [(_ (id ...) rel-exp1 rel-exp2)
     (let ([rel1 rel-exp1] [rel2 rel-exp2])
       (lambda (id ...)
         (lambda@ (sk fk subst)
           (let ([gl2 (rel2 id ...)])
             ((interleave-non-overlap sk fk)
              (@ (rel1 id ...) initial-sk initial-fk subst)
              (@ gl2 initial-sk initial-fk subst)
              fail
              gl2)))))]))

(define interleave-non-overlap
  (lambda (sk fk)
    (letrec
      ([interleave
         (lambda (q1 q2 gl1 gl2)
           (cond
             [(null? q1) (if (null? q2) (fk) ((finish-interleave sk fk) q2))]
             [else (let ([fk (cdr q1)] [subst (car q1)])
		(if (not (eq? (initial-fk) (satisfied? gl2 subst)))
		  (interleave q2 (fk) gl2 gl1)
		  (@ sk (lambda () (interleave q2 (fk) gl2 gl1)) subst)))]))])
      interleave)))

(define satisfied?
  (lambda (gl subst)
    (@ gl initial-sk initial-fk subst)))
\end{alltt}

Here, again, \texttt{finish} takes whatever is left to do after one of
the streams is exhausted.  But, this time if it can be shown that
either goal can be satisfied with the same substitution, we drop
one of the results.  It is worthwhile to compare \texttt{satisfied}
with \texttt{query}.  The place where it differs is
\texttt{satisfied?} has an additional argument, \texttt{subst}, which
is used in place of \texttt{empty-subst}.  Thus, we see that
\texttt{query} could be defined using \texttt{satisfied?} by passing
in \texttt{empty-subst} as its second argument.  By comparing the
result to the invocation of \texttt{initial-fk}, we know that we could not
find a substitution starting at the substitution that was originally
passed into \texttt{satisfied?}.  But, we have negated that result,
which means we could find such a result.

Finally, we can intersect a sequence of relations.
\begin{alltt}
(define-syntax intersect-relation
  (syntax-rules ()
    [(_ (id ...) rel-exp ...)
     (intersect-relation-aux (id ...) () rel-exp ...)]))

(define-syntax intersect-relation-aux
  (syntax-rules ()
    [(_ (id ...) ([g rel-exp] ...))
     (let ([g rel-exp] ...)
       (lambda (id ...)
         (all (g id ...) ...)))]
    [(_ (id ...) (let-pair ...) rel-exp0 rel-exp1 ...)
     (intersect-relation-aux (id ...)
       (let-pair ... [g rel-exp0]) rel-exp1 ...)]))
\end{alltt}

\texttt{Exercise e:} Comparing \texttt{intersect-relation-aux} to
\texttt{extend-relation-aux} leads to the observation that the only
way they differ is by the choice of combining the relation calls.
\texttt{intersect-relation} uses \texttt{all}, whereas
\texttt{extend-relation} uses \texttt{any}.  Implement
\texttt{intersect-relation/all!} and
\texttt{intersect-relation/all!!}, which use the combiners
\texttt{all!} and \texttt{all!!}, respectively.\endofexercise{}

\texttt{Exercise f:} All four relation-construction operators have the
same shape.  Implement a macro-generating macro that when used defines
one of these four macros.

Here is an example of its use.

\begin{alltt}
(define parents-of-scouts
  (extend-relation (a1 a2)
    (fact () 'sam 'rob)
    (fact () 'roz 'sue)
    (fact () 'rob 'sal)))

(define parents-of-athletes
  (extend-relation (a1 a2)
    (fact () 'sam 'roz)
    (fact () 'roz 'sue)
    (fact () 'rob 'sal)))

(define busy-parents
  (intersect-relation (a1 a2) parents-of-scouts parents-of-athletes))

(define conscientious-parents
  (extend-relation (a1 a2) parents-of-scouts parents-of-athletes))

> (solve 5 (x) (exists (y) (busy-parents x y)))
(((x.0 roz))
 ((x.0 rob)))

> (solve 7 (x) (exists (y) (conscientious-parents x y)))
(((x.0 sam))
 ((x.0 roz))
 ((x.0 rob))
 ((x.0 sam))
 ((x.0 roz))
 ((x.0 rob)))
\end{alltt}

\noindent
In these calls to \texttt{solve}, we created an goal with
\texttt{exists} in order to avoid seeing the children.

\texttt{Exercise d} The second example introduces a new problem.
Since we believe that both occurrences of Roz, Sam, and Rob refer to
the same people we probably would be as happy seeing their names only
once.  Revise \texttt{solve} to so that only the \emph{first} occurrences of
these names appears.\endofexercise{}

In the remainder of the paper, we present some additional goals,
consider the role of recursion in our logic system, and study some
famous examples that display some of the power of logic programming.

\section{Additional goals}

In this section we introduce some additional operators, which rely on
the underlying structure.  In each instance, we are expanding the
kinds of goals that are available.  Among these are
\texttt{fail} and \texttt{succeed}; an operator
\texttt{let*-inject/everything} for running Scheme expressions that
are lexically enclosed in a substitution, and three useful,
miscellaneous operators: \texttt{fails}, \texttt{instantiated}, and
\texttt{view-subst}.

The grammar for goals \texttt{<A>} completes the language.
\begin{alltt}
<A> =
     <relation call>
   | (exists (id ...) <A>*)
   | fail
   | succeed
   | (all <A>*)
   | (all! <A>*)
   | (all!! <A>*)
   | (any <A>*)
   | <additional goal>
   | <or any Scheme expression that evaluates to these,
       since these are all values.>

<additional goal> =
     (let*-inject/everything ([var_0 ([var bool] ...) Scheme-exp] ...) <A>*)
   | (fails <A>)
   | (succeeds <A>)
   | (instantiated <var>)
   | (view-subst <t>)
\end{alltt}

\noindent
where \texttt{<t>} is a term, and \texttt{<var>} is a variable.

\subsection{Interfacing Scheme functions}

Consider the macro \texttt{let-inject/everything} below.

\begin{alltt}
(define-syntax if/bc
  (syntax-rules ()
    [(_ #t conseq alt) conseq]
    [(_ #f conseq alt) alt]))

(define-syntax let-inject/everything
  (syntax-rules ()
    [(_ ([t ([var bool] ...) scheme-expression] ...) body ...)
     (lambda@ (sk fk subst)
       (@ (exists (t ...)
            (all! (== t (let ([var (let ([x (subst-in var subst)])
                                     (if/bc bool (nonvar! x) x))]
                              ...)
                          scheme-expression))
              ...
              (all body ...)))
          sk fk subst))]))

(define nonvar!
  (lambda (t)
    (if (var? t)
      (error 'nonvar! "Logic variable ~s found after substituting."
        (concretize t))
      t)))
\end{alltt}

At first blush, it seems rather daunting, but let's consider why we
have it.  This allow us to run Scheme expressions \texttt{exp ...}
using the current substitution as an environment for some of the free
variables of \texttt{exp}.  So naturally we must access the underlying
substitution \texttt{subst}.  That is the only reason for the
\texttt{lambda@}.  We avoid \texttt{cutk}, since we have applied an
$\eta$ reduction.  First each \texttt{t} is a fresh variable.  Then we
add each \texttt{t} in sequence to the substitution.  We bind each
\texttt{var} variable lexically to the value of the variable in the
substitution.  If \texttt{bool} is true, then we signal an error if
its argument is a variable.  Otherwise, we don't care what kind of an
argument is seeping through to Scheme.

There are several ways that we can use the preceding macro.  First, we
can have a \texttt{let*} variant \texttt{let*-inject/everything}
below.  Next we have versions of these two that either check
(\texttt{let-inject} and \texttt{let*-inject}) or don't
(\texttt{let-inject/no-check} and \texttt{let*-inject}) whether each
variable is not associated with an other variable.  The only subtlety
in these macros is that in the \texttt{let*} variant, we make sure
that the \texttt{t} variable that we are binding lexically is included
as one of the free variables of the Scheme expression.  We chose the
\texttt{no-check} variant for this fresh variable.

\begin{alltt}
(define-syntax let*-inject/everything
  (syntax-rules ()
    [(_ () body0 body1 ...) (all body0 body1 ...)]
    [(_ ([t0 ([var0 bool0] ...) scheme-expression0]
         [t1 ([var1 bool1] ...) scheme-expression1]
         ...)
       body0 body1 ...)
     (let-inject/everything ([t0 ([var0 bool0] ...) scheme-expression0])
       (let*-inject/everything ([t1 ([t0 #f][var1 bool1] ...) scheme-expression1] ...)
         body0 body1 ...))]))

(define-syntax let-inject
  (syntax-rules ()
    [(_ ([t (var ...) scheme-expression] ...) body ...)
     (let-inject/everything ([t ([var #t] ...) scheme-expression] ...) body ...)]))

(define-syntax let-inject/no-check
  (syntax-rules ()
    [(_ ([t (var ...) scheme-expression] ...) body ...)
     (let-inject/everything ([t ([var #f] ...) scheme-expression] ...) body ...)]))

(define-syntax let*-inject
  (syntax-rules ()
    [(_ ([t (var ...) scheme-expression] ...) body ...)
     (let*-inject/everything ([t ([var #t] ...) scheme-expression] ...) body ...)]))

(define-syntax let*-inject/no-check
  (syntax-rules ()
    [(_ ([t (var ...) scheme-expression] ...) body ...)
     (let*-inject/everything ([t ([var #f] ...) scheme-expression] ...) body ...)]))
\end{alltt}

Suppose we want to restrict the answers of \texttt{grandpa} so that
someone isn't a grandfather unless his child's name starts with the
letter, ``r.''  Jon's child's name is Sam, so Jon is no
longer considered a grandfather. But, Sam's child's name is
Rob, so Rob's children are still someone's grandchildren.

\begin{alltt}
(define grandpa
  (relation (grandad grandchild)
    (to-show grandad grandchild)
    (exists (parent)
      (all
        (father grandad parent)
        (let*-inject/everything ([p ([parent #t]) (not (starts-with-r? parent))])
          (== p #f)
          (father parent grandchild))))))

(define starts-with-r?
  (lambda (x)
    (and
      (symbol? x)
      (string=? (string (string-ref (symbol->string x) 0)) "r"))))
\end{alltt}

\begin{alltt}
> (solve 10 (x y) (grandpa x y))
(((x.0 sam) (y.0 sal))
 ((x.0 sam) (y.0 pat)))
\end{alltt}

The Scheme expression is arbitrary.  The Scheme expression acts like an
goal, but can do anything that any Scheme expression can do, including
capturing continuations, setting variables, writing to files, etc.  The
full panoply of options is available to the user.  We abstract this use
with a handy operator \texttt{predicate} and its \texttt{no-check} variant.

\begin{alltt}
(define-syntax predicate
  (syntax-rules ()
    [(_ (var ...) scheme-expression)
     (let-inject ([t (var ...) (not scheme-expression)])
       (== t #f))]))

(define-syntax predicate/no-check
  (syntax-rules ()
    [(_ (var ...) scheme-expression)
     (let*-inject/no-check ([t (var ...) (not scheme-expression)])
       (== t #f))]))
\end{alltt}

\subsection{\texttt{fails}, \texttt{instantiated}, and \texttt{view-subst}}

Below is the function \texttt{fails}, which fails when its goal succeeds and
succeeds when its goal fails.  Basically, we hand build both the success
and failure continuations.

\begin{alltt}
(define fails
  (lambda (gl)
    (lambda@ (sk fk subst cutk)
      (@ gl
        (lambda@ (ign-fk ign-subst ign-cutk) (fk))
        (lambda () (@ sk fk subst cutk))
        subst
        cutk)))
\end{alltt}

\noindent
And here is an example of \texttt{fails}.

\begin{alltt}
(define grandpa
  (relation (grandad grandchild)
    (to-show grandad grandchild)
    (exists (parent)
      (all
        (father grandad parent)
        (fails (predicate (parent) (starts-with-r? parent)))
        (father parent grandchild)))))
\end{alltt}

\begin{alltt}
> (solve 10 (x y) (grandpa x y))
(((x.0 jon) (y.0 rob))
 ((x.0 jon) (y.0 roz)))
\end{alltt}

To determine if a variable, \texttt{t}, is instantiated, use
\texttt{(instantiated t)} as an goal and this definition.

\begin{alltt}
(define instantiated
  (lambda (t)
    (predicate/no-check (t) (not (var t)))))
\end{alltt}

\noindent
At this point, \texttt{t} is either some variable or some other term.

To view a substitution, use \texttt{(view-subst t)} with this
definition.  The definition of \texttt{concretize-subst} should
be obvious, since it simply concretizes every variable in
a substitution.

\begin{alltt}
(define view-subst
  (lambda (t)
    (lambda@ (sk fk subst cutk)
      (pretty-print (subst-in t subst))
      (pretty-print (concretize-subst subst))
      (@ sk fk subst cutk))))
\end{alltt}

Here is a new definition of \texttt{grandpa}, like an earlier one,
but views the substitution.

\begin{alltt}
(define grandpa
  (relation _ (grandad grandchild)
    (to-show grandad grandchild)
    (exists (parent)
      (all
        (father grandad parent)
        (father parent grandchild)
        (view-subst grandchild)))))
\end{alltt}

\begin{alltt}
> (exists (x y) (solve 10 (grandpa x y)))

rob
((grandad.0 x.0)
 (grandchild.0 y.0)
 (x.0 jon)
 (parent.0 sam)
 (y.0 rob))
\end{alltt}

\begin{alltt}
roz
((grandad.0 x.0)
 (grandchild.0 y.0)
 (x.0 jon)
 (parent.0 sam)
 (y.0 roz))
\end{alltt}

\begin{alltt}
sal
((grandad.0 x.0)
 (grandchild.0 y.0)
 (x.0 sam)
 (parent.0 rob)
 (y.0 sal))

pat
((grandad.0 x.0)
 (grandchild.0 y.0)
 (x.0 sam)
 (parent.0 rob)
 (y.0 pat))

(((x.0 jon) (y.0 rob))
 ((x.0 jon) (y.0 roz))
 ((x.0 sam) (y.0 sal))
 ((x.0 sam) (y.0 pat)))
\end{alltt}

This completes the discussion of the features and implementation of
our logic system.  We have accomplished this using merely eight
people.  The population of our world is about to grow.

\section{Recursive definitions}

In this section we introduce two interesting problems.  The first
finds the youngest common ancestor of two people in our world.  The
second is the well-known ``Towers of Hanoi'' problem.  The second
is interesting because it uses recursion, \texttt{predicate}, and
\texttt{let-inject} in one relation.  We start with the youngest common
ancestor problem.

\subsection{Youngest common ancestor}

Suppose that we want to know if someone is a (patrilineal) ancestor.
We know that if someone old is the father of someone young, then the
old person is a patrilineal ancestor.  But, also, if the old person is
the father of someone not so old, and the not so old person is the
ancestor of the young person, then we know that we have an ancestor.
This way of describing ancestor is defined directly in our logic
system.  We add a few more facts to \texttt{father} to make the
outcomes a bit more interesting.  Specifically, we add that ``Jon is
the father of Hal,'' ``Hal is the father of Ted,'' and ``Sam is the
father of Jay.''

\begin{alltt}
(define father
  (extend-relation (a1 a2) father
    (fact () 'jon 'hal)
    (fact () 'hal 'ted)
    (fact () 'sam 'jay)))
\end{alltt}

We are now ready to solve the problem that we stated earlier.  To do
this, we first define and test the ancestor relation.

\begin{alltt}
(define ancestor
  (extend-relation
    (relation (old young)
      (to-show old young)
      (father old young))
    (relation (old young)
      (to-show old young)
      (exists (not-so-old)
        (all (father old not-so-old) (ancestor not-so-old young))))))
\end{alltt}

\noindent
\texttt{Exercise 10:} Redefine the previous definition of
\texttt{ancestor} as one relation using \texttt{any}.\endofexercise

Here is a simple test.

\begin{alltt}
> (solve 100 (x y) (ancestor x y))
(((x.0 jon) (y.0 sam))
 ((x.0 rob) (y.0 sal))
 ((x.0 rob) (y.0 pat))
 ((x.0 sam) (y.0 roz))
 ((x.0 jon) (y.0 hal))
 ((x.0 hal) (y.0 ted))
 ((x.0 sam) (y.0 jay))
 ((x.0 jon) (y.0 rob))
 ((x.0 jon) (y.0 roz))
 ((x.0 jon) (y.0 jay))
 ((x.0 jon) (y.0 sal))
 ((x.0 jon) (y.0 pat))
 ((x.0 sam) (y.0 sal))
 ((x.0 sam) (y.0 pat))
 ((x.0 jon) (y.0 ted)))
\end{alltt}

Once we have the concept of ancestor, it is easy to think in terms of
a common ancestor.  Two people share a common ancestor if somewhere
along their respective ancestor chains, their paths cross.  Here is
how we can write that in our logic system.

\begin{alltt}
(define common-ancestor
  (relation (young-a young-b old)
    (to-show young-a young-b old)
    (all (ancestor old young-a) (ancestor old young-b))))

> (solve 4 (x) (common-ancestor 'pat 'jay x))
(((x.0 jon) (y.0 sam)))
\end{alltt}

\noindent
This says that Jon and Sam are both common
ancestors of Pat and Jay.

If two people share two common ancestors, then we can determine if one
of the common ancestors is younger than the other common ancestor.

\begin{alltt}
(define younger-common-ancestor
  (relation (young-a young-b old not-so-old)
    (to-show young-a young-b old not-so-old)
    (all
      (common-ancestor young-a young-b not-so-old)
      (common-ancestor young-a young-b old)
      (ancestor old not-so-old))))
\end{alltt}

\noindent
According to \texttt{relation}, the ``\texttt{(all}'' and matching
``\texttt{)}'' are unnecessary, but we use them for clarification.

\begin{alltt}
> (solve 4 (x y) (younger-common-ancestor 'pat 'jay x y))
(((x.0 jon) (y.0 sam)))
\end{alltt}

\noindent
Thus Sam is the younger of the two common ancestors.

We finally come to the problem that we are most interested in, which
is how do we determine the youngest common ancestor.  We already know
that Pat and Jay share Sam and Jon, but we want the youngest among the
common ancestors. Since Jon must be older than Sam, the answer should
be Sam.

\begin{alltt}
(define youngest-common-ancestor
  (relation (young-a young-b not-so-old)
    (to-show young-a young-b not-so-old)
    (all
      (common-ancestor young-a young-b not-so-old)
      (exists (y)
        (fails (younger-common-ancestor young-a young-b not-so-old y))))))

> (solve 4 (x) (youngest-common-ancestor 'pat 'jay x))
(((x.0 sam)))
\end{alltt}

\noindent
The tricky part of this is that if we find a younger ancestor,
then the one we have chosen is not the youngest common ancestor.  So, the
ancestor is the youngest common ancestor provided each attempt to find
a younger common ancestor fails.

What is interesting about this approach is that it is recursive: we
define \texttt{ancestor} in terms of \texttt{ancestor}.  Although
we don't use recursion to implement our logic system, our model
relies heavily on the idea that users are facile with recursion
and we rely heavily on the fact that Scheme supports recursion.  For
instance, the recursion supported by \texttt{define} in these four
definitions could just as easily have been supported using
\texttt{letrec}.  Furthermore, we can bind \texttt{father} lexically,
so that the expression takes any binary relation as an argument.

\begin{alltt}
(define youngest-common-ancestor
  (lambda (father)
    (letrec ([ancestor ...]
             [common-ancestor ...]
             [younger-common-ancestor ...]
             [youngest-common-ancestor ...])
      youngest-common-ancestor)))
\end{alltt}

\noindent
This would also solve a problem related to an organizational chart.
If we pass a relation, say \texttt{supervisor}, instead of
\texttt{father}, then \texttt{youngest-common-ancestor} would find the
least common supervisor.  In general, this procedure produces the
\emph{least upper bound}, provided one exists, of a \emph{finite}
binary relation.

\subsection{Comparison with Seres and Spivey}
The similarities with Seres and Spivey are striking.  In fact, a
subset of our model maps directly onto theirs, although our goal
has been a full implementation of logic programming, including
many of the sullied goals as well as some meta operations.

Using \texttt{==} our Scheme embedding resembles their Haskell
embedding.  Where we differ is that we would be limited to using only
\texttt{any}, \texttt{all}, and \texttt{==}.  We would no longer have
\texttt{relation} and \texttt{extend-relation}, and all the sullied
operators.  This means that we could use \texttt{lambda} to define
relations.  For example, we can define \texttt{father} and
\texttt{ancestor} like this,

\begin{alltt}
(define father
  (lambda (dad child)
    (any
      (all (== dad 'jon) (== child 'sam))
      (all (== dad 'sam) (== child 'rob))
      (all (== dad 'sam) (== child 'roz))
      (all (== dad 'rob) (== child 'sal))
      (all (== dad 'rob) (== child 'pat))
      (all (== dad 'jon) (== child 'hal))
      (all (== dad 'hal) (== child 'ted))
      (all (== dad 'sam) (== child 'jay)))))
\end{alltt}

\begin{alltt}
(define ancestor
  (lambda (old young)
    (any
      (father old young)
      (exists (not-so-old)
        (all (father old not-so-old) (ancestor not-so-old young))))))
\end{alltt}
\noindent
And this can be tested similarly.
\begin{alltt}
> (solve 20 (x) (ancestor 'jon x))
(((x.0 jon) (y.0 sam))
 ((x.0 jon) (y.0 hal))
 ((x.0 jon) (y.0 rob))
 ((x.0 jon) (y.0 roz))
 ((x.0 jon) (y.0 jay))
 ((x.0 jon) (y.0 sal))
 ((x.0 jon) (y.0 pat))
 ((x.0 jon) (y.0 ted)))
\end{alltt}

Does the Haskell embedding differ in any significant way from our
embedding in Scheme?  Yes, besides avoiding sullied operators, there
is a fundamental difference.  Everything that works in the Haskell
embedding works in the Scheme embedding, but not vice versa.  Because
the Haskell embedding does unification piecewise within an
\texttt{all}, any time that the unification fails to match, there is
automatic backtracking.  That is not the case with \texttt{relation}
and \texttt{fact}.  In our embedding, if unification fails, it invokes
the failure continuation, immediately.  It is as though each relation
has a lock on it and a term either opens it or a new one is tried.  In
order to accomplish this in the Haskell embedding, they would need
\texttt{all!} or require that an unsuccessful unification invoke a
failure continuation

In sum, the Haskell embedding is good as far as it goes, but it
leaves many of the more interesting aspects of logic programming
unresolved.  The approach of treating every goal as a stream
of substitutions is not far from our approach.  Since we have
substitutions \texttt{subst} and failure continuations \texttt{fk}
in every goal, we could use a different representation of the
body of the goal, where all but \texttt{fk} would comprise
a data structure and the \texttt{fk} would be a stream (thunk).
Then each goal closure could be modelled as the \texttt{cons}ing
of the data structure to a stream.  Because this is a relatively
small program, making this last step in order to use the stream
monad seems like overkill, especially since this approach does not
appear to extend naturally to the all important sullied goals.

\subsection{``Towers of Hanoi''}

Three poles (a \emph{left}, a \emph{middle}, and a \emph{right}) can hold
disks of various sizes provided that a larger one is never on top of a
smaller one.  The initial state of the problem has a set of \emph{n}
disks (all different sizes) sitting on the left pole.  The goal is to
place the entire set of disks on the middle pole.  Only the top disk
of any pole can be moved to a different pole and then that disk
becomes the top disk of the chosen pole.\footnote{This solution has been derived from
page 141 of \emph{Programming in Prolog Fourth Edition} by
W.\ F.\ Clocksin and C.\ S.\ Mellish.}
\begin{alltt}
(define towers-of-hanoi
  (letrec
      ([move
         (extend-relation (a1 a2 a3 a4)
           (relation/cut cut ()
             (to-show 0 _ _ _)
             cut)
           (relation (n a b c)
             (to-show n a b c)
             (all
               (predicate (n) (positive? n))
               (let-inject ([m (n) (- n 1)])
                 (move m a c b)
                 (predicate (a b) (printf "Move a disk from ~s to ~s~n" a b))
                 (move m c b a)))))])
    (relation (n)
      (to-show n)
      (move n 'left 'middle 'right))))
\end{alltt}

\begin{alltt}
> (begin (solution (towers-of-hanoi 3)) (void))
Move a disk from left to middle
Move a disk from left to right
Move a disk from middle to right
Move a disk from left to middle
Move a disk from right to left
Move a disk from right to middle
Move a disk from left to middle
\end{alltt}

The algorithm is straightforward. First, figure out how to solve the
problem for one fewer disks and then move that stack of disks as a
virtual disk.  The use of \texttt{predicate} allows us to have a
procedure that writes one move.  Since we are displaying information,
we know that the value of \texttt{printf} is not false.  Also, the
\texttt{move} subtracts one from the number of disks using
\texttt{let-inject} and its first relation uses the anonymous variable
three times.  (Recall that the anonymous variable unifies with
everything, but it adds nothing to the substitution.)

\subsection{The difference between success and truth}

We revisit \texttt{any} to make a point about the difference between
\emph{success} and \emph{truth}.  Consider the following three
relations (\texttt{test1}, \texttt{test2}, and \texttt{test3}), which
rely only on \texttt{lambda} as in the Haskell embedding.

\begin{alltt}
> (define test1
    (lambda (x)
      (any (predicate () (< 4 5))
        (let-inject ([x^ () (< 6 7)])
          (== x x^)))))

> (solution (x) (test1 x))
((x.0 x.0))
\end{alltt}
\begin{alltt}
> (define test2
    (lambda (x)
      (any
        (predicate () (< 5 4))
        (let-inject ([x^ () (< 6 7)])
          (== x x^)))))

> (solution (x) (test2 x))
((x.0 #t))
\end{alltt}
\begin{alltt}
> (define test3
    (lambda (x y)
      (any
        (let-inject ([x^ () (< 5 4)])
          (== x x^))
        (let-inject ([y^ () (< 6 7)])
          (== y y^)))))

> (solution (x y) (test3 x y))
((x.0 #f) (y.0 y.0))
\end{alltt}

The first two should not be much of a surprise.  In the first example,
\texttt{4} is less than \texttt{5}, so \texttt{x} remains
uninstantiated, and \texttt{6} is less than \texttt{7}, so \texttt{x}
is instantiated in the second example.  In the last example, however,
we discover that \texttt{y} remains uninstantiated even though
\texttt{5} is \emph{not} less than \texttt{4}.  Why?
\texttt{let-inject}s like those above always succeed until its body is
considered.  So, succeeding is not the same as being true in our logic
system.

\section{Three famous problems}

Three famous problems that we discuss are the so-called
\texttt{append} problem, the type-inference problem of a typed variant
of the lambda calculus with constants, conditional expressions,
primitives, and polymorphic \texttt{let}, and a generalization of
Prolog's \texttt{name} pedicate.  Before we can begin this walk down
memory lane, we must enlarge the set of possible terms and
consequently change the behavior of five functions: \texttt{subst-in},
\texttt{ground?}, \texttt{relatively-ground?},
\texttt{concretize-term}, and \texttt{unify*}.

\subsection{Enlarging the set of terms}

Presently, a term is a variable or something that can be compared
trivially.  Now, we include in the set of terms those values that
cannot be compared trivially, such as pairs and vectors.  We restrict
our concerns to pairs.

\begin{alltt}
(define subst-in
  (lambda (t subst)
    (cond
      [(var? t)
       (cond
         [(assq t subst) => commitment->term]
         [else t])]
      [(pair? t)
       (cons
         (subst-in (car t) subst)
         (subst-in (cdr t) subst))]
      [else t])))

(define ground?
  (lambda (t)
    (cond
      [(var? t) #f]
      [(pair? t) (and (ground? (car t)) (ground? (cdr t)))]
      [else #t])))

(define relatively-ground?
  (lambda (term vars)
    (cond
      [(var? term) (not (memq term vars))]
      [(pair? term)
       (and (relatively-ground? (car term) vars)
            (relatively-ground? (cdr term) vars))]
      [else #t])))

(define concretize-term
  (lambda (t env)
    (cond
      [(var? t) (concretize-var t env)]
      [(pair? t)
       (let-values (carct env) (concretize-term (car t) env)
         (let-values (cdrct env) (concretize-term (cdr t) env)
           (values (cons carct cdrct) env)))]
      [else (values t env)])))
\end{alltt}

These are not significant changes.  They each walk recursively
through the term and apply the obvious operator to the results of
the recursive calls.

Here is an interesting example,

\begin{alltt}
> (let-lv (x y z)
    (let ([term `(p ,x ,y (g ,z))])
      (let ([s (compose-subst (unit-subst y z) (unit-subst x `(f ,y)))]
            [r (compose-subst (unit-subst x 'a) (unit-subst z 'b))])
        (let ([new-term (subst-in term s)])
          (printf "~s~n" (concretize new-term))
          (printf "~s~n" (concretize (subst-in new-term r)))
          (let ([sr (compose-subst s r)])
            (printf "~s~n" (concretize-subst sr))
            (concretize (subst-in term sr)))))))
(p (f y.0) z.0 (g z.0))
(p (f y.0) b (g b))
((y.0 b) (x.0 (f y.0)) (z.0 b))
(p (f y.0) b (g b))
\end{alltt}

In the example, we demonstrate a fact about substitutions: it does not
matter if we apply the substitutions to a term one at a time or apply
the composed substitution to the same term.

Next, we must change \texttt{unify*} (Recall that \texttt{unify*} is
called from \texttt{unify}.) to accomodate this new kind of term.  We
can ask if two data structures are \texttt{equal?}, which does a
recursive tree walk, comparing subparts.  If they are equal,
\texttt{equal?} responds with true, otherwise, it responds with false.
The redefinition of \texttt{unify*} below shares that attribute with
\texttt{equal?}. That is, when two data structures are equal,
\texttt{unify*} returns the empty substitution, otherwise, it returns
false.  But, unification is more than just equality.  The function
\texttt{unify*} takes two terms, and returns a substitution that allows
for the two terms to be perceived as \emph{equal} if the substitution
were applied to the two terms.  To accomplish this, each variable in
the two terms is added to the substitution by associating some term
with it.  In the recursive tree walk, two leaves that are aligned must
be \texttt{equal?}.  If one argument has a variable and the other one
contains something other than a variable, then that pair is added to
the substitution.  If the same variable is aligned in both arguments,
then the substitution remains unchanged.  If both are variables, then
one of them is treated as the term.  Each time something is added to
the substitution, it is a commitment. So, as the recursive tree walk
continues, it refines previous commitments.

The version of \texttt{unify*} below takes any two terms and returns a
substitution if the terms unify and returns false, otherwise.

\begin{alltt}
(define unify*
  (lambda (t u)
    (cond
      [(trivially-equal? t u) empty-subst]
      [(var? t) (if (occurs? t u) #f (unit-subst t u))]
      [(var? u) (if (occurs? u t) #f (unit-subst u t))]
      [(and (pair? t) (pair? u))
       (cond
         [(unify* (car t) (car u))
           => (lambda (s-car)
                (cond
                  [(unify* (subst-in (cdr t) s-car) (subst-in (cdr u) s-car))
                   => (lambda (s-cdr)
                        (compose-subst s-car s-cdr))]
                  [else #f]))]
         [else #f])]
      [else #f])))
\end{alltt}
There are only three kinds of terms for us to consider: trivial
values, variables, and pairs.  The first case is straightforward.  Two
terms (including two variables) unify and return the empty
substitution if they are trivially equal.  If at least one of them is
a variable, then the other becomes the term associated with it,
provided that that term does not contain an occurrence of the
variable.  Two pairs might unify if their \texttt{car}s unify.  But,
before we determine if the \texttt{cdr}s unify, we must take the
substitution returned from successfully unifying the \texttt{car}s,
its commitments, and apply it to the \texttt{cdr}s.  This brings the
\texttt{cdr}s up-to-date with those commitments.  Then all the
commitments from unifying the \texttt{car}s, \texttt{s-car}, and all
the commitments from unifying the substituted for \texttt{cdr}s,
\texttt{s-cdr}, are composed.

Do not underestimate just how difficult it is to understand the pair
case.  As it it written, it looks rather straightforward, but when we
process a deeply nested term, we make lots of commitments and they
must be repeatedly refined by future substitutions.  It is a testament
to the power of recursion that it can look this simple.

The check for an occurrence of a variable in a term below is a
straightforward recursive tree walk, however, for reasons of efficiency,
most logic systems have chosen not to include it.  Later, we show a
variant of unification that simply avoids it even though there might
be an occurrence.

\begin{alltt}
(define occurs?
  (lambda (var term)
    (cond
      [(var? term) (eq? term var)]
      [(pair? term) (or (occurs? var (car term)) (occurs? var (cdr term)))]
      [else #f])))
\end{alltt}

\noindent
\texttt{Exercise 11:} Each of the functions, \texttt{subst-in},
\texttt{ground?}, \texttt{relatively-ground},
\texttt{concretize-term}, \texttt{unify*}, and \texttt{occurs?}
treats pairs.  Include vectors as terms and allow the values in a
vector to be any term.\endofexercise

\noindent
\texttt{Exercise 12:} All calls to \texttt{unify} can be improved by
passing it success and failure continuations, making sure to thread
them through the auxiliary calls.  Revise the entire system to make
this improvement.\endofexercise

\subsection{Unification without the occurs check}

It is also possible to completely avoid the occurs check even if
there is an occurs-check violation.  In most Prologs, there is a
conscious decision to avoid the occurs check, but not too many of
them have a way to avoid it even if there is a violation. In
this section we present such a unifier.\footnote{The trick used here
also appears in SICTus Prolog.}

Before we can discuss the unifier, we must redefine \texttt{subst-in}
to account for decisions that will be made within the unifier.  We
choose to use \texttt{subst-in} sparingly, so when we do use it, we
have more work to do.  Before, \texttt{subst-in} merely replaced each
variable by its associated term.  Now, however, it starts over
with that term.  When it has no association, it stops.
\begin{alltt}
(define subst-in
  (lambda (t subst)
    (cond
      [(var? t)
       (cond
         [(assq t subst)
          => (lambda (c)
               (subst-in (commitment->term c) subst))]
         [else t])]
      [(pair? t)
       (cons (subst-in (car t) subst) (subst-in (cdr t) subst))]
      [else t])))
\end{alltt}

The unifier below avoids \texttt{subst-in} until it is ready to do a
\texttt{compose-subst}.  The two auxiliary procedures each take a
variable, but one takes another variable and the other takes something
that is not a variable.

\begin{alltt}
(define unify
  (lambda (t u subst)
    (cond
      [(trivially-equal? t u) subst]
      [(var? t) (if (var? u)
                    (unify-var/var t u subst)
                    (unify-var/value t u subst))]
      [(var? u) (unify-var/value u t subst)]
      [(and (pair? t) (pair? u))
       (cond
         [(unify (car t) (car u) subst)
          => (lambda (car-subst)
               (unify (cdr t) (cdr u) car-subst))]
         [else #f])]
      [else #f])))
\end{alltt}

The procedure \texttt{unify-var/var}, unifies the term associated with
the first variable against the term associated with the second one, if
they are committed.  If one of them is committed and the other is not,
then we set up a loop in \texttt{uncommitted/committed} below that
follows the committed one until either the same variable comes up, or
it ends up with a value.  If both variables are uncommitted, and we
already know that they are not the same from the test in
\texttt{unify}, then we naively extend the substitution.  It's
probably easier to skip to the committed \texttt{u-var} case first,
before studying the committed \texttt{t-var} case.
\begin{alltt}
(define unify-var/var
  (lambda (t-var u-var s)
    (cond
      [(assq t-var s)
       => (lambda (ct)
            (cond
              [(assq u-var s)
               => (lambda (cu)
                    (let ([u-term (commitment->term cu)]
                          [t-term (commitment->term ct)])
                      (unify t-term u-term s)))]
              [else ((committed/uncommitted u-var s) ct)]))]
      [(assq u-var s) => (committed/uncommitted t-var s)]
      [else (extend-subst t-var u-var s)])))
\end{alltt}
Formally, we could define \texttt{extend-subst} like this,
\begin{alltt}
(define extend-subst
  (lambda (var t refining)
    (compose-subst (unit-subst var t) refining)))
\end{alltt}
\noindent
but, consider the simplicity of \texttt{extend-subst} below.  We have
a variable and a term that we would like to naively include in a
substitution.  If the variable has no association in the substitution,
the variables in the term are not in \texttt{(map commitment->var
refining)}, and if the term is not the same as the variable, then we can
use this naive definition,

\begin{alltt}
(define extend-subst
  (lambda (var t refining)
    (cons (commitment var t) refining)))
\end{alltt}

But, we must convince ourselves that it is the right definition.
Clearly, we must be certain that its first two arguments are not the
same, for if they were, the result would be the original substitution.
Also, if the first argument has an association in the substitution,
then we know that its associated term would be removed from the
original substitution.  Finally, if the second argument contains any
variables with associations in the substitution, their associated
terms would affect the term that would be committed in the extended
substitution.
\begin{alltt}
(define committed/uncommitted
  (lambda (t-var s)
    (lambda (cu)
      (let loop ([cm cu])
        (let ([u-term (commitment->term cm)])
          (cond
            [(eq? u-term t-var) s]
            [(and (var? u-term) (assq u-term s)) => loop]
            [else (extend-subst t-var u-term s)]))))))
\end{alltt}
The procedure \texttt{unify-var/value} is the interesting part of this
algorithm.  Now we know that the second argument is a non-variable
(i.e., a value).  First, we check to see if the variable is committed
and if so, unify against its associated term. If the value is ground
(contains no variables), then we just extend the substitution.  Now,
if the variable is \emph{uncommitted} and the value of the second
argument is a \emph{pair}, then we have the situation like before when
we used the occurs check.  But, this time, we will do something else.
Since we know that we have a pair, we construct a pair with two new
pieces and associate it with \texttt{t-var} in the substitution.  If
either is ground, we leave that piece unchanged.  When it is not
ground, we replace that piece by a variable and unify that variable
with the term.  We use the new substitution to unify with whatever
piece was not ground.  If it not a pair, we do the same as above.

\begin{alltt}
(define unify-var/value
  (lambda (t-var u-value subst)
    (cond
      [(assq t-var subst)
       => (lambda (ct)
            (unify (commitment->term ct) u-value subst))]
      [(ground? u-value) (extend-subst t-var u-value subst)]
      [(pair? u-value)
       (let ([car-val (car u-value)]
             [cdr-val (cdr u-value)])
         (cond
           [(ground? car-val)
            (cond
              [(ground? cdr-val)
               (extend-subst t-var (cons car-val cdr-val) subst)]
              [else (let ([d-var (var 'd*)])
                      (unify d-var cdr-val
                        (extend-subst t-var
                          (cons car-val d-var) subst)))])]
           [else
             (let ([a-var (var 'a*)]
                   [cdr-val (cdr u-value)])
               (cond
                 [(ground? cdr-val)
                  (unify a-var car-val
                    (extend-subst t-var (cons a-var cdr-val) subst))]
                 [else (let ([d-var (var 'd*)])
                         (cond
                           [(unify a-var car-val
                              (extend-subst t-var (cons a-var d-var) subst))
                            => (lambda (subst)
                                 (unify d-var cdr-val subst))]
                           [else #f]))]))]))]
      [else (extend-subst t-var u-value subst)])))
\end{alltt}
This allows us to produce a legitimate substitution in the example
that failed the occurs check.  In order to actually view the
substitution, we need to use an auxiliary procedure
\texttt{subst-vars-recursively}, which is nearly the same as
\texttt{subst-in}, but when it follows the associated term of a
variable, it makes sure that the associated commitment is not found
again by removing it from the substitution.

\begin{alltt}
(define subst-vars-recursively
  (lambda (t subst)
    (cond
      [(var? t)
       (cond
         [(assq t subst) =>
          (lambda (c)
            (subst-vars-recursively
              (commitment->term c) (remq c subst)))]
         [else t])]
      [(pair? t)
       (cons
         (subst-vars-recursively (car t) subst)
         (subst-vars-recursively (cdr t) subst))]
      [else t])))

> (concretize-subst
    (let ([s (unify `(p ,x ,x) `(p ,y (f ,y)) empty-subst)])
      (let ([vars (map commitment->var s)])
        (map commitment vars (subst-vars-recursively vars s)))))
((a*.0 f a*.0)
 (d*.0 (f . d*.0))
 (y.0 f (f . d*.0))
 (x.0 f (f . d*.0)))
\end{alltt}

If we look closely at the output, we can see the circularity in the
associated term of \texttt{a*.0} and \texttt{d*.1}.  Therefore, any
term that contains them is circular, which includes the terms
associated with \texttt{x.0}, and \texttt{y.0}.

\subsubsection{``Towers of Hanoi'' revisited}

Before, we look at the three famous problems, let's take another look at
the ``Towers of Hanoi'' problem.  It is less than satisfying that the
solution is not a value returned but just some displaying of information.
Instead, we can replace those effects by other effects and build
the answer in a table.  Then, that path can be the result.  Thus, we are
free to write functions that process the path.  For example, we can now
determine how many steps it takes for any n.  Before, we were limited by
our willingness to read and process screens or files.
\begin{alltt}
(define towers-of-hanoi-path
  (let ([steps '()])
    (let ([push-step (lambda (x y) (set! steps (cons `(,x ,y) steps)))])
      (letrec
          ([move
             (extend-relation (a1 a2 a3 a4)
               (relation/cut cut ()
                 (to-show 0 _ _ _)
                 cut)
               (relation (n a b c)
                 (to-show n a b c)
                 (all
                   (predicate (n) (positive? n))
                   (let-inject ([m (n) (- n 1)])
                     (move m a c b)
                     (predicate (a b) (push-step a b))
                     (move m c b a)))))])
        (relation (n path)
          (to-show n path)
          (begin
            (set! steps '())
            (any
              (fails (move n 'l 'm 'r))
              (== path (reverse steps)))))))))

> (exists (path) (solution (towers-of-hanoi-path 3 path)))
(3 ((l m) (l r) (m r) (l m) (r l) (r m) (l m)))
\end{alltt}

The primary difference between this version and the earlier version is that
in this version there is a lexical variable \texttt{steps} that holds each
step, where before we printed each step.  Then, by forcing failure with
\texttt{fails}, we are guaranteed to process the second rule.  It always
succeeds, since \texttt{path} is guaranteed to be uninstantiated. We
reverse the steps so that it looks like our earlier output. Everything else
is the same.

\noindent
\texttt{Exercise 13:} Use this definition of
\texttt{towers-of-hanoi-path} to produce a table of the number of
disks with the number of steps it takes to move that number of disks.\endofexercise

Our unifier now handles pairs (lists), so we can continue the
discussion of the three famous problems.

\subsection{The \emph{Append} Problem}

We can often mimic value-returning functions with relations
that take an \emph{additional} argument.  For example,  we
can write a function that concatenates \emph{two} lists.

\begin{alltt}
(define concat
  (lambda (xs ys)
    (cond
      [(null? xs) ys]
      [else (cons (car xs) (concat (cdr xs) ys))])))
\end{alltt}

\begin{alltt}
> (concat '(a b c) '(u v))
(a b c u v)
\end{alltt}

\noindent
or the equivalent

\begin{alltt}
> (solution (q)
    (let-inject ([t () (concat '(a b c) '(u v))])
      (== t q)))
((q.0 (a b c u v)))
\end{alltt}

\noindent
And we can write the corresponding relation over \emph{three} lists,

\begin{alltt}
(define concat
  (extend-relation (a1 a2 a3)
    (fact (xs) '() xs xs)
    (relation (x xs ys zs)
      (to-show `(,x . ,xs) ys `(,x . ,zs))
      (concat xs ys zs))))
\end{alltt}
\noindent

\begin{alltt}
> (solve 6 (q) (concat '(a b c) '(u v) q))
(((q.0 (a b c u v))))
\end{alltt}

\noindent which determines that there is only one answer and which
shows if we concatenate \texttt{(a b c)} to \texttt{(u v)}, we get
\texttt{(a b c u v)}. But, we can move \texttt{q} to another position.

\begin{alltt}
> (solve 6 (q) (concat '(a b c) q '(a b c u v)))
(((q.0 (u v))))
\end{alltt}

\noindent
This time we determine that \texttt{q} should be \texttt{(u v)}, which
is \emph{not} possible with \texttt{concat} as a function.
Similarly, we can determine that \texttt{q} is \texttt{(a b c)}.

\begin{alltt}
> (solve 6 (q) (concat q '(u v) '(a b c u v)))
(((q.0 (a b c))))
\end{alltt}

\noindent
But what if we include another variable?
\begin{alltt}
> (solve 6 (q r) (concat q r '(a b c u v)))
(((q.0 ()) (r.0 (a b c u v)))
 ((q.0 (a)) (r.0 (b c u v)))
 ((q.0 (a b)) (r.0 (c u v)))
 ((q.0 (a b c)) (r.0 (u v)))
 ((q.0 (a b c u)) (r.0 (v)))
 ((q.0 (a b c u v)) (r.0 ())))
\end{alltt}

\noindent
We get all the ways that we might concatenate
two lists to form \texttt{(a b c u v)}.
Now, what if we include yet another variable?

\begin{alltt}
> (solve 6 (q r s) (concat q r s))
(((q.0 ()) (r.0 xs.0) (s.0 xs.0))
 ((q.0 (x.0)) (r.0 xs.0) (s.0 (x.0 . xs.0)))
 ((q.0 (x.0 x.1)) (r.0 xs.0) (s.0 (x.0 x.1 . xs.0)))
 ((q.0 (x.0 x.1 x.2)) (r.0 xs.0) (s.0 (x.0 x.1 x.2 . xs.0)))
 ((q.0 (x.0 x.1 x.2 x.3)) (r.0 xs.0) (s.0 (x.0 x.1 x.2 x.3 . xs.0)))
 ((q.0 (x.0 x.1 x.2 x.3 x.4)) (r.0 xs.0) (s.0 (x.0 x.1 x.2 x.3 x.4 . xs.0))))
\end{alltt}

\noindent
Here we see that the empty list and any list yield that list.  Then we
get all sorts of constructed lists with the first $N$ elements of the
list chosen as variables of that length.  There is no bound on the
number of answers.

We can also get an unbounded number of answers with only two variables.

\begin{alltt}
> (solve 6 (q r) (concat q '(u v) `(a b c . ,r)))
(((q.0 (a b c)) (r.0 (u v)))
 ((q.0 (a b c x.0)) (r.0 (x.0 u v)))
 ((q.0 (a b c x.0 x.1)) (r.0 (x.0 x.1 u v)))
 ((q.0 (a b c x.0 x.1 x.2)) (r.0 (x.0 x.1 x.2 u v)))
 ((q.0 (a b c x.0 x.1 x.2 x.3)) (r.0 (x.0 x.1 x.2 x.3 u v)))
 ((q.0 (a b c x.0 x.1 x.2 x.3 x.4)) (r.0 (x.0 x.1 x.2 x.3 x.4 u v))))
\end{alltt}

\noindent
The first answer is the one we expect, where \texttt{q} is
instantiated to \texttt{(a b c)} and \texttt{r} is instantiated to
\texttt{(u v)}.  But, then we discover that \texttt{q} could be a bit
longer.

And here is an unbounded number of answers with a single variable.

\begin{alltt}
> (solve 6 (q) (concat q '() q))
(((q.0 ()))
 ((q.0 (x.0)))
 ((q.0 (x.0 x.1)))
 ((q.0 (x.0 x.1 x.2)))
 ((q.0 (x.0 x.1 x.2 x.3)))
 ((q.0 (x.0 x.1 x.2 x.3 x.4))))
\end{alltt}

\noindent
Again, the first answer is the one that we expect, but
the others make sense, too, since no matter what we replace
the variables \texttt{x.}\emph{i} with, we create a
legitimate equation.

A program like \texttt{concat} is what excited the
logic programming world.  It was called \texttt{append}
because of the use of that name in Lisp, but since
\texttt{concat} is defined globally, it would be wise to
avoid overriding the built-in Scheme function, \texttt{append}.

\subsection{The Type-Inference Problem}

The second famous problem is the type-inference problem.  We start by
considering integers and booleans.  Next, we include some familiar
primitives.  When we are comfortable with those features we include
conditionals, followed by lexical variables, then \texttt{lambda},
application, and \texttt{fix} expressions. Finally, we include
polymorphic \texttt{let}.  Type inference allows for the system to
determine a unique type if the expression has one.

\subsubsection{Buiding a type inferencer with small relations}

The language for which we infer a type is basically a lambda-calculus
variant of Scheme.  We have chosen, however, to parse this variant
into a language where every expression has a tag as in \texttt{parse}
below.  We have also included an \texttt{unparse} below to get back
the original Scheme variant.

\begin{alltt}
(define parse
  (lambda (e)
    (cond
      [(symbol? e) `(var ,e)]
      [(number? e) `(intc ,e)]
      [(boolean? e) `(boolc ,e)]
      [else
        (case (car e)
          [(zero?) `(zero? ,(parse (cadr e)))]
          [(sub1) `(sub1 ,(parse (cadr e)))]
          [(+) `(+ ,(parse (cadr e)) ,(parse (caddr e)))]
          [(if) `(if ,(parse (cadr e)) ,(parse (caddr e)) ,(parse (cadddr e)))]
          [(fix) `(fix ,(parse (cadr e)))]
          [(lambda) `(lambda ,(cadr e) ,(parse (caddr e)))]
          [(let) `(let ([,(car (car (cadr e))) ,(parse (cadr (car (cadr e))))])
                    ,(parse (caddr e)))]
          [else `(app ,(parse (car e)) ,(parse (cadr e)))])])))
\end{alltt}

\begin{alltt}
(define unparse
  (lambda (e)
    (case (car e)
      [(var) (cadr e)]
      [(intc) (cadr e)]
      [(boolc) (cadr e)]
      [(zero?) `(zero? ,(unparse (cadr e)))]
      [(sub1) `(sub1 ,(unparse (cadr e)))]
      [(+) `(+ ,(unparse (cadr e)) ,(unparse (caddr e)))]
      [(if) `(if ,(unparse (cadr e)) ,(unparse (caddr e)) ,(unparse (cadddr e)))]
      [(fix) `(fix ,(unparse (cadr e)))]
      [(lambda) `(lambda (,(car (cadr e))) ,(unparse (caddr e)))]
      [(let)
       `(let ([,(car (car (cadr e)))
               ,(unparse (cadr (car (cadr e))))])
          ,(unparse (caddr e)))]
      [(app) `(,(unparse (cadr e)) ,(unparse (caddr e)))])))
\end{alltt}

While you are reading the code for the type system, \texttt{!-}, it is
important to keep in mind that although we are presenting a type
inferencing algorithm, it is just a relatively simple logic program.

\texttt{!-} corresponds to the mathematical symbol $\vdash$
(turnstile) and reads ``we can infer.''  That is, from looking at the
relation \texttt{int-rel} and the definition of \texttt{!-} below, we
can read it as, ``From \texttt{g} \emph{we can infer} that \texttt{x}
is of type \texttt{int} provided that \texttt{x} is an \texttt{intc}.''
For now, we leave \texttt{g} unspecified.

In the expressions below, we use \texttt{int}, \texttt{bool}, and
\texttt{-->} for our type constructors.  We define \texttt{int}
and \texttt{bool} to avoid using lots of quotes.

\begin{alltt}
(define int 'int)
(define bool 'bool)
\end{alltt}

\begin{alltt}
(define int-rel
  (fact (g x) g `(intc ,x) int))

(define !- int-rel)
\end{alltt}

\begin{alltt}
> (let ([result (solution (g) (!- g (parse 17) int))])
    `(!- ,(cadar result) 17 int))
(!- g.1 17 int)

> (let ([result (solution (g ?) (!- g (parse 17) ?))])
    `(!- ,(cadar result) ,(unparse (parse 17)) ,(caadr result)))
(!- g.1 17 int)
\end{alltt}

In the first example, we verify that \texttt{17} is of type
\texttt{int}.  In the second example, the type is unknown, but
whatever is instantiated to the variable \texttt{?} is the
type.  In this case, \texttt{?} is instantiated to \texttt{int}.
The existence of \texttt{g.0} in the answers indicates that \texttt{g}
is uninstantiated, so these work for all possible \texttt{g}s.

As a way to abstract the behavior of our testing technology, we
use \texttt{infer-type} below, which abbreviates some of the
repetition of the first two examples and supports the idea that
the expression might not have a type.

\begin{alltt}
(define-syntax infer-type
  (syntax-rules ()
    [(_ g term type)
     (cond
       [(solution (g type) (!- g (parse term) type))
        => (lambda (result)
             `(!- ,(cadr (car result)) ,term ,(cadr (cadr result))))]
       [else #f])]))
\end{alltt}

Next, we include \texttt{bool-rel} below in \texttt{!-}.
\begin{alltt}
(define bool-rel
  (fact (g x) g `(boolc ,x) bool))

(define !- (extend-relation (a1 a2 a3) !- bool-rel))
\end{alltt}
\noindent
\texttt{Exercise 14:} Test \texttt{infer-type} over true and false.\endofexercise

Before we include relations for the arithmetic primitives, we observe
that we need to use \texttt{all!}.  This means that whenever there is
failure, all the goals fail.  We do this because our type
inferencer has this deterministic behavior.  There cannot be any
backtracking.  That is, once a decision is made, it cannot be
reconsidered!

Now we can extend \texttt{!-} below with the relations
\texttt{zero?-rel}, \texttt{sub1-rel}, and \texttt{+-rel}, which
correspond to the primitves \texttt{zero?}, \texttt{sub1}, and
\texttt{+}, respectively.

\begin{alltt}
(define zero?-rel
  (relation (g x)
    (to-show g `(zero? ,x) bool)
    (all! (!- g x int))))

(define sub1-rel
  (relation (g x)
    (to-show g `(sub1 ,x) int)
    (all! (!- g x int))))

(define +-rel
  (relation (g x y)
    (to-show g `(+ ,x ,y) int)
    (all! (!- g x int) (!- g y int))))
\end{alltt}

\begin{alltt}
(define !- (extend-relation (a1 a2 a3) !- zero?-rel sub1-rel +-rel))
\end{alltt}

\begin{alltt}
> (infer-type g '(zero? 24) ?)
(!- g.1 (zero? 24) bool)
\end{alltt}

\begin{alltt}
> (infer-type g '(zero? (+ 24 50)) ?)
(!- g.1 (zero? (+ 24 50)) bool)
\end{alltt}

The type system can infer that \texttt{(zero? 24)} is of type
\texttt{bool}, because it can infer that \texttt{24} is of type
\texttt{int}.  It can infer that \texttt{(+ 24 50)} is of type
\texttt{int}, so the answer in the second example must be of type
\texttt{bool}.  We can, of course, make more complicated examples
using \texttt{zero?}, \texttt{sub1}, and \texttt{+}, but if they have
a type, it is \texttt{int} or \texttt{bool}.  For example,

\begin{alltt}
> (infer-type g '(zero? (sub1 (+ 18 (+ 24 50)))) ?)
(!- g.1 (zero? (sub1 (+ 18 (+ 24 50)))) bool)
\end{alltt}

Although our parser (and unparser) expects a larger language, at each
stage of defining \texttt{!-}, we are writing a type inferencer for a
larger and larger language.  When we have defined \texttt{!-} for
\texttt{let}, then we have a type inferencer for the full language.
To reiterate, the language starts out very small! It only contains
integers.  Then, as we progress, it gets bigger.  But, the beauty of
type inferencing, is that these little relations grow naturally.  Of
course, we cannot write the relation for \texttt{zero?}\ until we have
a relation for numbers and booleans, so there is a natural ordering to
some extent.

In this type system, we must preserve the property that every
well-typed expression has \emph{one} type.  So, what do we do about
conditionals?  Easy.  We require that not only must the test be of
type \texttt{bool}, but the true branch and the false branch must
have the same type.  In a language without variables, \texttt{lambda}
expressions, applications, \texttt{fix} expressions, and \texttt{let}
expressions, that means that they must both be of type \texttt{int}
or they must both be of type \texttt{bool}.  By extending
\texttt{!-}, we can now handle \texttt{if} expressions.

\begin{alltt}
(define if-rel
  (relation (g t test conseq alt)
    (to-show g `(if ,test ,conseq ,alt) t)
    (all! (!- g test bool) (!- g conseq t) (!- g alt t))))
\end{alltt}

\begin{alltt}
(define !- (extend-relation (a1 a2 a3) !- if-rel))
\end{alltt}

\begin{alltt}
> (infer-type g '(if (zero? 24) 3 4) ?)
(!- g.0 (if (zero? 24) 3 4) int)
\end{alltt}

\noindent
Not surprisingly, we discover that the type of the test is \texttt{bool}
and the type of the entire expression is \texttt{int}.

Next, we include lexical variables, which are represented using
symbols.  What is the type of \texttt{(zero? a)}?  If the type of
\texttt{a} is \texttt{int}, then we know that the type of the entire
expression is \texttt{bool}, but if the type of \texttt{a} is
\texttt{bool}, then the expression does not have a type.  How do we
determine the type of \texttt{a}?  We look in \texttt{g}, which is a
type environment that associates lexical (both generic and
non-generic) variables with types.  So far we have ignored \texttt{g},
but now we consider its content using \texttt{non-generic} (a tag)
variables.  We extend \texttt{!-} to include a relation for variables.

\begin{alltt}
(define var-rel
  (relation (g v t)
    (to-show g `(var ,v) t)
    (all! (env g v t))))

(define !- (extend-relation (a1 a2 a3) !- var-rel))
\end{alltt}

\begin{alltt}
(define non-generic-match-env
  (fact (g v t) `(non-generic ,v ,t ,g) v t))

(define non-generic-recursive-env
  (relation (g v t)
    (to-show `(non-generic ,_ ,_ ,g) v t)
    (all! (instantiated g) (env g v t))))
\end{alltt}

\begin{alltt}
(define env (extend-relation (a1 a2 a3)
              non-generic-match-env
              non-generic-recursive-env)))
\end{alltt}

\begin{alltt}
> (solution (g ?) (env `(non-generic b int (non-generic a bool ,g)) 'a ?))
((non-generic b int (non-generic a bool g.0)) a bool)
\end{alltt}

\begin{alltt}
> (infer-type `(non-generic a int ,g) '(zero? a) ?)
(!- (non-generic a int g.0) (zero? a) bool)
\end{alltt}

\begin{alltt}
> (infer-type `(non-generic b bool (non-generic a int ,g)) '(zero? a) ?)
(!- (non-generic b bool (non-generic a int g.0)) (zero? a) bool)
\end{alltt}

The first example tests \texttt{env}.  The environment starts out with
\texttt{int} bound to \texttt{b} and \texttt{bool} bound to
\texttt{a}.  The \texttt{non-generic-recursive-env} relation succeeds,
since we are looking up \texttt{a}, and then the
\texttt{non-generic-match-env} relation succeeds, since we find
\texttt{a}.  In the second answer, we have one item in the type
environment and the \texttt{non-generic-match-env} relation is
followed. In the third example, we have two items in the type
environment, so we take the \texttt{non-generic-recursive-env} relation,
then the \texttt{non-generic-match-env} relation succeeds,
since we have stripped off \texttt{b} and \texttt{bool}, leaving
\texttt{a} and its associated type.

Now that we can deal with lexical (non-generic) variables, we can
consider the relation for \texttt{lambda} expressions by extending
\texttt{!-}.

\begin{alltt}
(define lambda-rel
  (relation (g v t body type-v)
    (to-show g `(lambda (,v) ,body) `(--> ,type-v ,t))
    (all! (!- `(non-generic ,v ,type-v ,g) body t))))

(define !- (extend-relation (a1 a2 a3) !- lambda-rel))
\end{alltt}

\begin{alltt}
> (infer-type
    `(non-generic b bool (non-generic a int ,g))
    '(lambda (x) (+ x 5))
    ?)
(!- (non-generic b bool (non-generic a int g.0))
    (lambda (x) (+ x 5))
    (--> int int))
\end{alltt}

\begin{alltt}
> (infer-type
    `(non-generic b bool (non-generic a int ,g))
    '(lambda (x) (+ x a))
    ?)
(!- (non-generic b bool (non-generic a int g.0))
    (lambda (x) (+ x a))
    (--> int int))
\end{alltt}

\begin{alltt}
> (infer-type g '(lambda (a) (lambda (x) (+ x a))) ?)
(!- g.0 (lambda (a) (lambda (x) (+ x a)))
        (--> int (--> int int)))
\end{alltt}

In the first answer, we see that we have an arrow (\texttt{-->})
type.  The left argument of the arrow type is the type of argument
coming into the function, and the right argument of the arrow type is
the type of the result going out of the function.  So, the inferred
type is a function whose argument is an integer and whose result is an
integer.  The second answer states that the argument is an integer,
but consults the type environment to make sure that the argument going
out is an integer.  In the third example, we forget about the first
environment, because there are no free variables in the expression. We
see that the argument coming in is an integer, but the result is an
arrow type, which takes in an integer and returns an integer.  Close
inspection of the type (directly aligned below the item it is typing)
shows that for each \texttt{lambda} there is an arrow and for each
formal parameter there is a type.  Also, there is a type for the body
of each \texttt{lambda}.  If we think about the type from the inside
out, we see that \texttt{(+ x a)} is an integer only if \texttt{x} and
\texttt{a} are integers.  That determines the type of the inner
\texttt{lambda} and then the type of the outer \texttt{lambda}.  It is
important that we \emph{can} infer the type of \texttt{lambda}
expressions, even though we do not yet have application in our language.
This should be a bit of a surprise.

We come next to application.  In determining the type of an
application, we know that the operator in an application should be
some arrow type.  Furthermore, once we know that type, we know that
the type going out of that type is the same as the type of the entire
application and we know that the operand of the application must be
the type going into that type.

\begin{alltt}
(define app-rel
  (relation (g t rand rator)
    (to-show g `(app ,rator ,rand) t)
    (exists (t-rand)
      (all! (!- g rator `(--> ,t-rand ,t)) (!- g rand t-rand)))))

(define !- (extend-relation (a1 a2 a3) !- app-rel))
\end{alltt}

\begin{alltt}
> (infer-type g '(lambda (f) (lambda (x) ((f x) x))) ?)
(!- g.0
    (lambda (f) (lambda (x) ((f x) x)))
    (--> (--> type-v.0
              (--> type-v.0 t.0))
         (--> type-v.0 t.0)))
\end{alltt}

Here, the type of \texttt{f} is \texttt{(--> type-v.0 (--> type-v.0 t.0))}, so
the type of \texttt{x} must be \texttt{type-v.0}, and the type of
\texttt{(lambda (x) ((f x) x))} must be \texttt{(--> type-v.0 t.0)}.
As should be evident, once we add a relation for application, things
start to get a bit tricky.  We can no longer rely on aligning the
\texttt{lambda}s with the arrows.  Here we have two \texttt{lambda}s
and four arrows.  Yet another surprise.  Our inferencer is starting
to be clever.

We may be tempted to use our language to write (and test) recursive
functions.  To test the expression, we use the call-by-value \texttt{fix}
primitive:

\begin{alltt}
(define fix-rel
  (relation (g rand t)
    (to-show g `(fix ,rand) t)
    (all! (!- g rand `(--> ,t ,t)))))

(define !- (extend-relation (a1 a2 a3) !- fix-rel))
\end{alltt}

In Scheme, we define \texttt{fix} below.  Although \texttt{fix} can
be defined using simple \texttt{lambda} terms as in the \texttt{Y}
combinator, \emph{this} type system cannot determine a type for it.
Thus, \texttt{fix} must be primitive and the associated primitive
call's type can be inferred as above.

\begin{alltt}
(define fix
  (lambda (e)
    (e (lambda (z) ((fix e) z)))))
\end{alltt}

\begin{alltt}
> (infer-type
    g
    '((fix (lambda (sum)
             (lambda (n)
               (if (zero? n)
                 0
                 (+ n (sum (sub1 n)))))))
      10)
    ?)
(!- g.0
    ((fix (lambda (sum)
            (lambda (n)
              (if (zero? n)
                 0
                 (+ n (sum (sub1 n)))))))
     10)
    int)
\end{alltt}

Let's consider the following expression
\begin{alltt}
> ((fix (lambda (sum)
          (lambda (n)
            (+ n (sum (sub1 n))))))
   10)
\end{alltt}

It fails to terminate.  But, can we infer its type?  Yes, \emph{an
expression may have a type, even if evaluating it would lead to
nontermination.}  This is a confusing aspect of type inference.  We
know from the ``Halting Problem'' that we cannot tell in advance
whether evaluating an arbitrary expression will terminate, but
\emph{this} type inferencing system is guaranteed to terminate.  Thus,
we can infer the type before we run it.  As a result, information that
the run-time system can learn from the type (or the process of
inferring the type) can be put to good use.  Here is its type.

\begin{alltt}
> (infer-type
    g
    '((fix (lambda (sum)
             (lambda (n)
               (+ n (sum (sub1 n))))))
      10)
    ?)
(!- g.0
    ((fix (lambda (sum) (lambda (n) (+ n (sum (sub1 n)))))) 10)
    int)
\end{alltt}

\subsection{Polymorphic \texttt{let}}

The \texttt{let}-expression is a bit more subtle.  Let's take a look at
an expression that should type check, but won't in the absence of
\texttt{let}.

\begin{alltt}
> (infer-type
    g
    '((lambda (f)
        (if (f (zero? 5))
          (+ (f 4) 8)
          (+ (f 3) 7)))
      (lambda (x) x))
    ?)
#f
\end{alltt}

Because \texttt{f} becomes the non-generic identity, once a type for
\texttt{f} is determined, it must stay the same.  Obviously, we would
expect that the evaluation of ``\texttt{((lambda (f) ...) ...)}
to be 10, but it has no type.  If, however, we change the
expression to use \texttt{let}
\begin{alltt}
(let ([f (lambda (x) x)])
  (if (f (zero? 5))
    (+ (f 4) 8)
    (+ (f 3) 7)))
\end{alltt}

\noindent
and think about $\beta$-substituting for \texttt{f} throughout, then
we can see that this expression should have a type, \texttt{int}.
Instead of doing the substitution, we mark certain variables
\emph{generic} as they are placed in the environment.

This is the \emph{polymorphic} \texttt{let}, since the variable is
tagged with \texttt{generic} in the environment.  If the variable were
tagged with \texttt{non-generic}, then this would be the familiar
\texttt{let}.  We have only to determine what happens in environment
lookup when a variable with a \texttt{generic} tag is an arrow type.
Those who wish to include a more general \texttt{let} expression, one
whose binding variable is bound to a \texttt{non-generic}, feel free
to do so, but for our purposes, we assume that all right-hand sides of
\texttt{let} expressions are \texttt{lamdda} expressions.

\begin{alltt}
(define polylet-rel
  (relation (g v rand body t)
    (to-show g `(let ([,v ,rand]) ,body) t)
    (exists (t-rand)
      (all!
        (!- g rand t-rand)
        (!- `(generic ,v ,t-rand ,g) body t)))))

(define !- (extend-relation (a1 a2 a3) !- polylet-rel))
\end{alltt}

In order to implement these generics, we introduce a relation,
\texttt{instantiate}, which uses \texttt{let*-inject/no-check}, whose purpose
is to associate the type \texttt{(--> targ tresult)} with the type
\texttt{t}.

\begin{alltt}
(define instantiate
  (letrec
      ([instantiate-term
         (lambda (t env)
           (cond
             [(var? t)
              (cond
                [(assq t env)
                 => (lambda (pr)
                      (values (cdr pr) env))]
                [else (let ([new-var (var (var-id t))])
                        (values new-var (cons `(,t . ,new-var) env)))])]
             [(pair? t)
              (let-values (a-t env) (instantiate-term (car t) env)
                (let-values (d-t env) (instantiate-term (cdr t) env)
                  (values (cons a-t d-t) env)))]
             [else (values t env)]))])
    (lambda (t)
      (let-values (ct env) (instantiate-term t '())
        ct))))
\end{alltt}

\begin{alltt}
(define generic-base-env
  (relation (g v targ tresult t)
    (to-show `(generic ,v (--> ,targ ,tresult) ,g) v t)
    (let*-inject/no-check ([t^ (targ tresult) (instantiate `(--> ,targ ,tresult))])
      (== t t^))))

(define generic-recursive-env
  (relation/cut cut (g v t)
    (to-show `(generic ,_ ,_ ,g) v t)
    (all! cut (env g v t))))

(define generic-env
  (extend-relation (a1 a2 a3)
    generic-base-env
    generic-recursive-env))

(define env
  (extend-relation (a1 a2 a3)
    env
    generic-env))
\end{alltt}

Now that we have extended our environments to handle generic
as well as non-generic variables, we can infer the right type.
\begin{alltt}
> (infer-type
    g
    '(let ([f (lambda (x) x)])
       (if (f (zero? 5))
         (+ (f 4) 8)
         (+ (f 3) 7)))
    ?)
(!- g.0
    (let ([f (lambda (x) x)])
      (if (f (zero? 5))
        (+ (f 4) 8)
        (+ (f 3) 7)))
    int)
\end{alltt}

\subsubsection{Type inhabitation}

We are going to do an experiment and in order to get the results
we want, we need to respecify the order of the relations.  Thus
we redefine \texttt{!-}.

\begin{alltt}
(define !-
  (extend-relation (a1 a2 a3)
    var-rel int-rel bool-rel zero?-rel sub1-rel +-rel
    if-rel lambda-rel app-rel fix-rel polylet-rel))
\end{alltt}

Here are four, perhaps unexpected, examples.

\begin{alltt}
> (solution (g ?) (!- g ? '(--> int int)))
((g.0 (non-generic v.0 (--> int int) g.0)) (?.0 (var v.0)))

\end{alltt}

\begin{alltt}
> (solution (g la f b) (!- g `(,la (,f) ,b) '(--> int int)))
((g.0 g.0) (la.0 lambda) (f.0 f.0) (b.0 (var f.0)))
\end{alltt}

\begin{alltt}
> (solution (g h r q z y t) (!- g `(,h ,r (,q ,z ,y)) t))
((g.0 (non-generic v.0 int g.0))
 (h.0 +)
 (r.0 (var v.0))
 (q.0 +)
 (z.0 (var v.0))
 (y.0 (var v.0))
 (t.0 int))
\end{alltt}

\begin{alltt}
> (solution (g h r q z y t u v) (!- g `(,h ,r (,q ,z ,y)) `(,t ,u ,v)))
((g.0 g.0)
 (h.0 lambda)
 (r.0 (v.0))
 (q.0 +)
 (z.0 (var v.0))
 (y.0 (var v.0))
 (t.0 -->)
 (u.0 int)
 (v.0 int))
\end{alltt}

The first example attempts to find an expression whose type is
\texttt{(--> int int)}, but instead finds a type environment that
binds that type to the variable \texttt{v.0}, and then the expression is
trivially \texttt{v.0}.  The second example produces an expression
given the type.  This is answering the question, ``What expression
\emph{inhabits} that type?''  In our case, the identity function
inhabits that type.  But, to make these first two examples work, we
had to place \texttt{var-rel} first in the definition of
\texttt{!-}, above.  In the third example, it infers that \texttt{t}
must be of \texttt{int} type.  Then since there is only one binary
operation that returns an \texttt{int} (i.e., \texttt{+}), it
determines \texttt{q} and \texttt{h}.  Next, we can infer that \texttt{r},
\texttt{z}, and \texttt{y} must be of \texttt{int} type, and what is
easier than making them all the same variable and placing it in the
initial type environment.  The last example only differs in the shape
of the resultant type.  Here it assumes that since the type contains
three parts, it must be an arrow type.  That means that \texttt{h}
must be the symbol \texttt{lambda}. Once again the only binary
operator is \texttt{+} making \texttt{z} and \texttt{y} be of
\texttt{int} type.

\texttt{Exercise d:} Take the results of these four test programs and
reconstruct what the terms are by substituting for each variable.\endofexercise

\subsection{Prolog's \texttt{name} as a relation}

Consider treating invertible binary operators as three-place
relations. The function
\texttt{invertible-binary-function->ternary-relation} below expects
that at most one of the three arguments is a variable and solves the
problem by determining which of the three variables is uninstantiated.

\begin{alltt}
(define invertible-binary-function->ternary-relation
  (lambda (op inverted-op)
    (extend-relation (a1 a2 a3)
      (relation (x y z)
        (to-show x y z)
        (all (fails (instantiated z))
          (let-inject ([z^ (x y) (op x y)])
            (== z z^))))
      (relation (x y z)
        (to-show x y z)
        (all (fails (instantiated y))
          (let-inject ([y^ (z x) (inverted-op z x)])
            (== y y^))))
      (relation (x y z)
        (to-show x y z)
        (all (fails (instantiated x))
          (let-inject ([x^ (z y) (inverted-op z y)])
            (== x x^))))
      (relation (x y z)
        (to-show x y z)
        (let-inject ([z^ (x y) (op x y)])
          (== z z^))))))

(define ++ (invertible-binary-function->ternary-relation + -))
(define -- (invertible-binary-function->ternary-relation - +))
(define ** (invertible-binary-function->ternary-relation * /))
(define // (invertible-binary-function->ternary-relation / *))

> (solution (x) (++ x 16.0 8))
((x.0 -8.0))

> (solution (x) (** 10 x 50))
((x.0 5))

> (solution (x) (-- 10 7 x))
((x.0 3))
\end{alltt}

And we can do something similar with invertible unary functions.
\begin{alltt}
(define invertible-unary-function->binary-relation
  (lambda (op inverted-op)
    (extend-relation (a1 a2)
      (relation (x y)
        (to-show x y)
        (all (fails (instantiated y))
          (let-inject ([y^ (x) (op x)])
            (== y y^))))
      (relation (x y)
        (to-show x y)
        (all (fails (instantiated x))
          (let-inject ([x^ (y) (inverted-op y)])
            (== x x^))))
      (relation (x y)
        (to-show x y)
        (begin
          (pretty-print "Third rule")
          (let-inject ([y^ (x) (op x)])
            (== y y^)))))))
\end{alltt}

\begin{alltt}
(define symbol->lnum
  (lambda (sym)
    (map char->integer (string->list (symbol->string sym)))))

(define lnum->symbol
  (lambda (lnums)
    (string->symbol (list->string (map integer->char lnums)))))

(define name
  (invertible-unary-function->binary-relation symbol->lnum lnum->symbol))
\end{alltt}
\begin{alltt}
> (solution (x) (name 'sleep x))
((x.0 (115 108 101 101 112)))

> (solution (x) (name x '(115 108 101 101 112)))
((x.0 sleep))
\end{alltt}

In the first example, we return the \texttt{char->integer} of each
character in \texttt{sleep}.  In the second, given a list of integers,
presumably derived from \texttt{char->integer}, it returns the symbol
made from those integers.  Thus, we have the Prolog relation
\texttt{name}.  For our purposes, which is an embedding in Scheme, it
is probably unnecessary, but it is interesting, nonetheless, that we
can define these two relation-generating Scheme functions.  There are
more unary functions that can be so treated, like
\texttt{symbol->string} and \texttt{string->symbol}, but we leave
their inclusion to the programmer who might need them.

\subsection{Proving a nontrivial theorem}
In this section, we present a simple program and then we prove a
simple fact about the program.  The program is the function
\texttt{mirror}, which takes an arbitrary S-expression of pairs
and atomic values and if its argument is a pair, it swaps the
\texttt{car} with the \texttt{cdr}, recursively.  Otherwise, the
atomic value is left unchanged.

Here is the definition of \texttt{mirror}.
\begin{alltt}
(define mirror
  (lambda (x)
    (cond
      [(not (pair? x)) x]
      [else (cons (mirror (cdr x)) (mirror (car x)))])))
\end{alltt}
and here is the theorem about this definition that we shall prove:
$$\forall x. \; x = (\mirror (\mirror x))$$

First of all, we have no notion of $\forall$.  Second, we have no
notion of what $=$ means.  We address these issues below.  On some
level, we know that $\forall x$ means that the predicate
must be true for every element of the domain of
the discourse--that is, all Scheme values. That is perhaps too
strong a statement. We want the formula $x = (\mirror (\mirror x))$ to
be true for every \emph{suitable} value $x$, that is, for every $x$ that
makes sense to pass to the procedure \texttt{mirror}.  $$\forall
x. \; (\suitable x) \wedge x = (\mirror (\mirror x))$$
The predicate $(\suitable x)$ restricts the values $x$ to be in the domain of
$mirror$.

Let's test the theorem on a few examples:

\begin{alltt}
> (mirror (mirror '(a b c)))
(a b c)
> (mirror (mirror '((a b) c)))
((a b) c)
\end{alltt}

Clearly, it makes sense to see if there are some obvious programs that
contradict the \emph{theorem}, but since we present the full proof of
the theorem, we know that such counterexamples do not exist.

Now, what does the $=$ mean?  We might be tempted to treat $=$ as a logical
equivalence, and try to show that \texttt{(== x (mirror (mirror x)))} in
our logical system. That would not be right. We must draw a distinction
between logical (i.e., tautological) equivalence, which is syntactic, and
domain equality (which is semantic). This distinction is akin to the
distinction between \texttt{eq?} and \texttt{equal?} in the pure functional
subset of Scheme. The relation $=$ that appears in our theorem is a binary
equality relation defined in our domain. We shall use EQ for $=$ to avoid
confusing this relation with the logical equivalence or Scheme
equality. Incidentally, we cannot formulate our theorem as \texttt{(== x
(mirror (mirror x)))} for another reason: the latter relation is empty, as
an attempt to unify \texttt{x} with \texttt{(mirror (mirror x))} would
create an unacceptable circularity.

The relation EQ is an equivalence relation on our domain, so it is
supposed to satisfy the usual axioms of reflexivity, symmetry, and
transitivity. Thus we need a way to introduce axioms. In mathematics, we
introduce a two argument entailment relation $\vdash$.
	$$\Gamma \vdash conseq$$
asserts \emph{conseq} subject to the list of assumptions $\Gamma$.  In
other words, \emph{conseq} is derivable from $\Gamma$ using the existing axioms
and inference rules. The list of assumptions can be empty (in which
case the notation above is truly an axiom). Thus the three axioms of
equivalence relations EQ can be stated as
\begin{eqnarray*}
&\vdash&({\textrm EQ} \; val \; val)\\
({\textrm EQ} \; a \; b)&\vdash&({\textrm EQ} \; b \; a)\\
({\textrm EQ} \; a \; c), ({\textrm EQ} \; c \; b)&\vdash&({\textrm EQ} \; a \; b)
\end{eqnarray*}
It is still proper to call these axioms \emph{schemas} because they contain free
variables. As usual, the free variables that occur on the
right-hand side (such as $a$ and $b$) are universally quantified and
the free variables that occur only on the left-hand side (such as $c$) are
existentially quantified.

In Prolog notation, we can write these axioms as
\begin{alltt}
proof(eq(Val,Val)).
proof(eq(B,A)) :- proof(eq(A,B)).
proof(eq(A,B)) :- proof(eq(A,C)), proof(eq(C,B)).
\end{alltt}
meaning that there is a proof of
\texttt{eq(Val,Val)}, a proof exists for \texttt{eq(B,A)} if there is a proof of
\texttt{eq(A,B)}, and that if \texttt{eq(A,C))} and \texttt{eq(C,B)} are
provable, then so is \texttt{eq(A,B)}.  The latter style makes our prover a
backward-chaining prover.

Our system is designed not so much for theorem proving, but for proof
verification (see Athena system).  It is important to let
the user specify exactly which axioms should participate in a proof of
each particular formula. Thus, we need a way to represent sets of
axioms. We introduce a first-class relation called \emph{kb}. The relation is
unary: its domain is the set of formulas. $({\mathrm kb} \; formula)$ is non-empty if
$formula$ is either an axiom or can be derived from axioms in finitely
many steps. Because our workhorse relations are unary, it helps
to add some syntactic sugar.
\begin{alltt}
(define-syntax extend-unary-relation
  (syntax-rules ()
    [(_ rel1 ...) (extend-relation (a1) rel1 ...)]))
\end{alltt}

We can write the three axioms of equivalence relations for EQ in our
notation as follows:

\begin{alltt}
(define EQ-axioms-atoms
  (lambda (kb)
    (extend-unary-relation
      (fact (val) `(EQ ,val ,val))
      (relation (a b) (to-show `(EQ ,a ,b)) (kb `(EQ ,b ,a)))
      (relation (a b) (to-show `(EQ ,a ,b))
        (exists (c)
          (kb `(EQ ,a ,c))
          (kb `(EQ ,c ,b)))))))
\end{alltt}

The first axiom, \emph{reflexivity}, says that something is equal to
itself.  To be more precise, identical things are equal: syntactic equality
implies semantic equality.  The second axiom, \emph{symmetry}, says that
$({\textrm EQ} \; a \; b)$ is provable if $({\textrm EQ} \; b \; a)$ is
provable.  Finally, we have the last axiom, \emph{transitivity}.  It says
that if we have $c$ so that both $({\textrm EQ} \; a \; c)$ and $({\textrm
EQ} \; c \; b)$ are provable, then we may conclude that $({\textrm EQ} \; a
\; b)$ is provable.

Recall that we have a fix point operator Y such that we can turn a
$\lambda$ expression into a recursive function.

\begin{alltt}
(Y (lambda (!)
     (lambda (n)
       (if (zero? n)
         1
         (* n (! (- n 1)))))))
\end{alltt}

A \texttt{LEAF} wrapped with \texttt{BTREE} is a \texttt{BTREE} and
a \texttt{ROOT} wrapped with \texttt{BTREE} is a \texttt{BTREE}
provided that its two sub-terms are \texttt{BTREE}s in the thus far
generated knowledge base, \texttt{kb}.

\begin{alltt}
(define is-a-BTREE
  (lambda (kb)
    (extend-unary-relation
      (fact (val) `(BTREE (LEAF ,val)))
      (relation (t1 t2)
        (to-show `(BTREE (ROOT ,t1 ,t2)))
        (all
          (kb `(BTREE ,t1))
          (kb `(BTREE ,t2)))))))
\end{alltt}

Then using these characterizations, we have an axiom for trees.  This
axiom says that two \texttt{ROOT}s are EQ if using
\texttt{kb}, their \texttt{car}s and \texttt{cdr}s are EQ.

We must now write our semantic equality relation EQ on our
domain.  We have to define which trees we shall consider equal.

\begin{alltt}
(define EQ-axioms-trees
  (lambda (kb)
    (extend-unary-relation
      (fact (val) `(EQ (LEAF ,val) (LEAF ,val)))
      (relation (a b c d)
        (to-show `(EQ (ROOT ,a ,b) (ROOT ,c ,d)))
        (all
          (kb `(EQ ,a ,c))
          (kb `(EQ ,b ,d)))))))
\end{alltt}
The fact in \texttt{EQ-axioms-trees} is redundant, since we can rely
on EQ's property of reflexivity.  Thus, we simplify the
definition.

\begin{alltt}
(define EQ-axioms-trees
  (lambda (kb)
    (relation (a b c d)
      (to-show `(EQ (ROOT ,a ,b) (ROOT ,c ,d)))
      (all
        (kb `(EQ ,a ,c))
        (kb `(EQ ,b ,d))))))
\end{alltt}

In addition, we have three axioms relating to \texttt{mirror} and EQ.

\begin{alltt}
(define EQ-axioms-MIRROR
  (lambda (kb)
    (extend-unary-relation
      (fact (val) `(EQ (LEAF ,val) (MIRROR (LEAF ,val))))
      (fact (t1 t2) `(EQ (MIRROR (ROOT ,t1 ,t2)) (ROOT (MIRROR ,t2) (MIRROR ,t1))))
      (relation (a b)
        (to-show `(EQ (MIRROR ,a) ,b))
        (exists (c)
          (kb `(EQ ,b (MIRROR ,c)))
          (kb `(EQ ,a ,c)))))))
\end{alltt}

The first axiom says that \texttt{mirror} has no effect on leaves.
The second axiom says that \texttt{mirror} of a \texttt{ROOT} is the
\texttt{ROOT} with mirror applied to the \texttt{cdr} and the
\texttt{car}.  This last axiom states that to show \texttt{(EQ
(MIRROR} $a$\texttt{)} $b$\texttt{)}, show that there exists a $c$
such that in the knowledge base \texttt{kb}
\texttt{(EQ} $b$ \texttt{(MIRROR} $c$\texttt{))} is provable and that
\texttt{(EQ $a$ $c$)}.

There is something subtle going on here.  We are proving a theorem
about terms; we are not running a program.  Therefore, we have used
the all uppercase symbols to remind us that we are not invoking
procedures like \texttt{EQ}, \texttt{MIRROR}, \texttt{ROOT}, or
\texttt{LEAF}.  They are just constants.
To be more precise, EQ, MIRROR, ROOT, and LEAF are functional symbols
of our term algebra. We build formulas from these symbols,
denoting various objects of our domain, and variables. Variables stand
for objects of our domain, thus our formulas are first-order. We are
interested in proving or verifying theorems: that is, given a
formula, a set of assumptions, and a set of axioms, we verify that the
resultant formula is provable using modus potens.

Our goal is to prove
$$\forall x. \; \suitable(x) \wedge x = (\mirror (\mirror x))$$
where suitable($x$) is btree($x$). For brevity, we introduce a predicate
GOAL such that
$$GOAL(x) === btree(x) \wedge x = (mirror (mirror x))$$
In other words, we introduce two axioms for our new literal GOAL:
\begin{eqnarray*}
	GOAL(x) &\vdash& btree(x) \wedge x = (\mirror (\mirror x))\\
	btree(x) \wedge x = (\mirror (\mirror x)) &\vdash& GOAL(x)
\end{eqnarray*}

\noindent For abbreviation we shall call the first axiom GoalRev and the second GoalFwd.  In the notation of our system, GoalFwd can be written as

\begin{alltt}
(define GOAL-fwd
  (lambda (kb)
    (relation (t)
      (to-show `(GOAL ,t))
      (kb `(BTREE ,t))
      (kb `(EQ (MIRROR (MIRROR ,t)) ,t)))))
\end{alltt}
and the act of adding it to the current set of axioms kb can be
written as
\begin{alltt}
(let ([kb (extend-unary-relation (GOAL-fwd kb) kb)]) ...)
\end{alltt}

In logic, we want to prove
	$$\vdash \forall x \; Goal(x)$$
We shall use the standard logical inference rule
``From $(C \rightarrow A(x))$, where $x$ is a variable that does not occur free in $C$,
conclude $(C \rightarrow \forall x \; A(x))$.''
where $C$ is true and $A(x)$ is $Goal(x)$. Thus, it's enough to prove
$$\vdash Goal(T)$$
where $T$ is some literal (constant).

We shall be doing a structural induction proof, which consists of the base
step and the induction step.  The proof follows the inductive structure of
our domain, BTREEs. For the base step, we have to prove $$\vdash
Goal(LEAF(Val))$$

Here's the proof by hand.  By the axiom,
$$\vdash BTREE(LEAF(Val))$$
Then by axiom,
$$\vdash EQ(LEAF(Val), MIRROR(LEAF(Val)))$$
With the axiom of symmetry of EQ,
$$\vdash EQ(MIRROR(LEAF(Val)), LEAF(Val))$$
Finally, using the axiom of EQ with respect to MIRROR,
$$\vdash EQ(MIRROR(MIRROR(LEAF(Val))), LEAF(VAL))$$

Then $Goal(Leaf(Val))$ follows from the GoalFwd axiom.  Here's how we ask
our system to verify the same proof.

\begin{alltt}
(let ([eigen-x (artificial-id `(,(var 'x) . ,(random 10)))])
  (concretize-subst
    (caar
      (query
	(let ([kb (Y init-kb-coll)])
	  (let ([kb (extend-unary-relation (GOAL-fwd kb) kb)])
	    (kb `(GOAL (LEAF ,eigen-x)))))))))
\end{alltt}

For the induction step, we have to prove that $$\vdash \forall t_{1}, t_{2} \;
Goal(t_{1}), Goal(t_{2}) \rightarrow Goal(ROOT(t_{1},t_{2}))$$

\noindent Again, by availing ourselves to the inference rule, we
merely need to prove that
$$\vdash Goal(t_{1}), Goal(t_{2}) \rightarrow Goal(ROOT(t_{2},t_{2}))$$
where $t_1$ and $t_2$ are some constants.

We shall now use the deduction theorem
$$A \vdash B  \Longleftrightarrow \; \vdash A \rightarrow B$$
(provided that we do not quantify the free variables that may occur in
$A$).

To be precise, first we rearrange $A,B \rightarrow C$
as $A \rightarrow (B \rightarrow C)$
so
\begin{eqnarray*}
	&\vdash& (A \wedge B) \rightarrow C\\
	&\vdash& A \rightarrow (B \rightarrow C)\\
      A &\vdash& B \rightarrow C\\
     A,B&\vdash& C
\end{eqnarray*}
So, we need to prove
$$Goal(t_{1}), Goal(t_{2}) \vdash Goal(ROOT(t_{1},t_{2}))$$

In our system,
\begin{alltt}
(let ([eigen-x (artificial-id `(,(var 'x) . ,(random 10)))]
        [eigen-y (artificial-id `(,(var 'y) . ,(random 10)))])
    (concretize-subst
      (caar
        (query
          (let ([kb (Y (lambda (kb)
                         (extend-unary-relation
                           (init-kb-coll kb)
                           (fact () `(GOAL ,eigen-x))
                           (fact () `(GOAL ,eigen-y))
                           (GOAL-rev kb))))])
            (let ([kb (GOAL-fwd kb)])
              (kb `(GOAL (ROOT ,eigen-x ,eigen-y)))))))))
\end{alltt}

We add to our current set of axioms assumptions $Goal(t_{1})$, $Goal(t_{2})$,
the axiom GoalRev, and the axiom GoalFwd. We then try to
prove $Goal(ROOT(t_{1},t_{2}))$. The system says that the relation
\texttt{(kb `(GOAL (ROOT ,eigen-x ,eigen-y)))} is satisfiable--there is a
proof of $Goal(ROOT(t_{1},t_{2}))$.

GoalRev in the above relation is
\begin{alltt}
(define GOAL-rev
  (lambda (kb)
    (extend-unary-relation
      (relation (t)
        (to-show `(BTREE ,t))
        (kb `(GOAL ,t)))
      (relation (t)                ; (GOAL t) => (EQ (MIRROR (MIRROR t)) t)
        (to-show `(EQ (MIRROR (MIRROR ,t)) ,t))
        (kb `(GOAL ,t))))))
\end{alltt}

In the above, \texttt{init-kb-coll} is the set of basic axioms, which we extend
with other axioms to prove one or the other branch of the complex
proof.  The \texttt{with-depth} is a way of making
sure that we don't loop while trying the axioms.  The number 5, which
is one larger than the number of arguments to \texttt{any}, manages
that.

\begin{alltt}
(define init-kb-coll
  (lambda (kb)
    (lambda (t)
      (with-depth 5
        (any
          ((is-a-BTREE kb) t)
          ((EQ-axioms-atoms kb) t)
          ((EQ-axioms-MIRROR kb) t)
          ((EQ-axioms-trees kb) t))))))

(define depth-counter-var (let-lv (*depth-counter-var*) *depth-counter-var*))

(define with-depth
  (lambda (limit gl)
    (lambda@ (sk fk subst cutk)
      (cond
        [(assq depth-counter-var subst)
         => (lambda (cmt)
              (let ([counter (commitment->term cmt)])
                (if (= counter limit)
                  (fk)
                  (let ([s (extend-subst depth-counter-var (+ counter 1) subst)])
                    (@ gl sk fk s cutk)))))]
        [else
          (let ([s (extend-subst depth-counter-var 0 subst)])
            (@ gl sk fk s cutk))]))))
\end{alltt}

The procedure \texttt{with-depth} takes an upper bound and an
goal and it returns an goal to be run in the same state
one more time than the limit for that goal.  It does this by
associating a counter with a substitution, so that a particular
goal that runs in that state gets run a limited number of times.
This, keeps infinite loops, which are natural when proving theorems,
from taking place.  Alternatively, with-depth limits the number of
applications of a particular axiom/rule when searching for a proof.
By extending the substitution on each invocation of the goal,
and by searching using \texttt{assq}, we are guaranteed to get the
most recent value of the counter associated with that substitution.

Now, we are ready to test the program to see if it can prove the
theorem.  But, before we do, we have one additional facet to explain.
A logician writes $\forall x \; P(x)$, but this is really the same as
$P(x)$.  But, to make the point, the $x$ has to be chosen arbitrarily.
Thus we can say that for any $x$, since it is chosen arbitrarily,
$P(x)$ holds.  The arbitrary variable is called an \emph{eigenvariable}.
We will model an eigenvariable using \texttt{artificial-id}, which we
recall produces a symbol.  In each of the four examples, we return a
substitution, which means that the \texttt{(GOAL ...)} succeeded.
Only the first and fourth examples are used for the proof.  The first
one proves the base case of the induction and the last one proves the
inductive case.  We leave the details for the reader to work out.
% Possibly more this paragraph higher.

\begin{alltt}
> (let ([eigen-x (artificial-id `(,(var 'x) . ,(random 10)))])
    (concretize-subst
      (caar
        (query
          (let ([kb (Y init-kb-coll)])
            (let ([kb (extend-unary-relation (GOAL-fwd kb) kb)])
              (kb `(GOAL (LEAF ,eigen-x)))))))))
((*depth-counter-var*.0 . 0)
 (*depth-counter-var*.0 . 1)
 (*depth-counter-var*.0 . 2)
 (a*.0 LEAF . d*.0)
 (d*.1 a*.0)
 (a*.1 . x.9)
 (d*.0 a*.1)
 (*depth-counter-var*.0 . 5)
 (*depth-counter-var*.0 . 4)
 (*depth-counter-var*.0 . 3)
 (*depth-counter-var*.0 . 4)
 (*depth-counter-var*.0 . 5)
 (a*.2 LEAF x.9)
 (d*.2 a*.2)
 (a*.3 MIRROR . d*.2)
 (d*.3 a*.3))

> (let ([eigen-x (artificial-id `(,(var 'x) . ,(random 10)))]
        [eigen-y (artificial-id `(,(var 'y) . ,(random 10)))])
    (concretize-subst
      (caar
        (query
          (let ([kb (Y (lambda (kb)
                         (extend-unary-relation
                           (init-kb-coll kb)
                           (GOAL-rev kb)
                           (fact () `(GOAL ,eigen-x))
                           (fact () `(GOAL ,eigen-y)))))])
            (kb `(BTREE ,eigen-y)))))))
()

> (let ([eigen-x (artificial-id `(,(var 'x) . ,(random 10)))]
        [eigen-y (artificial-id `(,(var 'y) . ,(random 10)))])
    (concretize-subst
      (caar
        (query
          (let ([kb (Y (lambda (kb)
                         (extend-unary-relation
                           (init-kb-coll kb)
                           (GOAL-rev kb)
                           (fact () `(GOAL ,eigen-x))
                           (fact () `(GOAL ,eigen-y)))))])
            (kb `(BTREE (ROOT ,eigen-x ,eigen-y))))))))
((*depth-counter-var*.0 . 0))

> (let ([eigen-x (artificial-id `(,(var 'x) . ,(random 10)))]
        [eigen-y (artificial-id `(,(var 'y) . ,(random 10)))])
    (concretize-subst
      (caar
        (query
          (let ([kb (Y (lambda (kb)
                         (extend-unary-relation
                           (init-kb-coll kb)
                           (fact () `(GOAL ,eigen-x))
                           (fact () `(GOAL ,eigen-y))
                           (GOAL-rev kb))))])
            (let ([kb (GOAL-fwd kb)])
              (kb `(GOAL (ROOT ,eigen-x ,eigen-y)))))))))
((*depth-counter-var*.0 . 0)
 (*depth-counter-var*.0 . 1)
 (a*.0 ROOT . d*.0)
 (*depth-counter-var*.0 . 2)
 (d*.1 a*.1)
 (t2.0 MIRROR . d*.1)
 (a*.1 . x.8)
 (d*.2 a*.2)
 (t1.0 MIRROR . d*.2)
 (a*.2 . y.3)
 (*depth-counter-var*.0 . 5)
 (a*.3 . t1.0)
 (a*.4 . t2.0)
 (a*.5 . t2.0)
 (a*.6 . t1.0)
 (d*.0 a*.3 . d*.3)
 (d*.3 a*.4)
 (d*.4 a*.7 . d*.5)
 (a*.7 MIRROR . d*.6)
 (d*.6 a*.5)
 (d*.5 a*.8)
 (a*.8 MIRROR . d*.7)
 (d*.7 a*.6)
 (*depth-counter-var*.0 . 4)
 (*depth-counter-var*.0 . 3)
 (d*.8 a*.0)
 (*depth-counter-var*.0 . 4)
 (a*.9 ROOT x.8 y.3)
 (d*.9 a*.9))
\end{alltt}

\section{Final thoughts}
In a relation call such as \texttt{(exists (x) (foo x 'a y))} we have
three different kinds of values.  The symbol \texttt{'a} is a raw
value, the lexical variables, \texttt{foo} and \texttt{y}, become
values as part of the call, and the logic variable \texttt{x} becomes
a value (or is shared with another logic variable) when its argument
unifies with another value.  Having the call allow for their
intermingling clarifies why we need to manage their scopes.  Because
the call is awaiting other arguments, we do not need to think about
this in terms of a finished call that returns a value until these
additional arguments are absorbed by the result of the relation call.

We have given up two main features of logic programming?  First, we do
not have meta-level operations that allow for construction of relations
from existing relations.  This may be retrieved by building the relations
as data structures and using \texttt{eval} to construct the actual
relations when they are needed.  This solution leaves much to be
desired and the way Prolog handles this is cleaner, especially since
\texttt{eval} should only be used in the rarest of circumstances.  It
may be possible, however, with higher-order capabilities to get
around most of these needs.  Second, and more importantly, we have
abandoned the database capability associated with logic
programming. By that, we mean the ability of relations to be
treated as a global monolithic relation.  To circumvent this
shortcoming, one can write a driver that knows some subset (possibly
all) of the relations and their arities and whenever a relation of a
particular arity is invoked, it searches through all the relations of
that arity.  This would be easy to set up with
\texttt{extend-relation} and an association list that associates an
arity with an extended relation of that arity. We can further
partition this association list by replacing the arity with a type
signature.  But, this approach would have to re-address the cut.
Since, this browsing capability is not required by the problem domains
we have in mind, probably it is best that it be developed on an as
needed basis.  From the start we have been developing a tool that
would allow for easy implementation of language-related programs such
as type inferencers, interpreters, and compilers.  These clearly do
not need a global database.

One disadvantage of this implementation is that there is no obvious place
to change the depth-first search strategy to one that supports
breadth-first search.  In its place we have made relations
lexically-scoped, first-class, and extensible, which seems to be a fair
tradeoff.  One approach that might work for getting back other search
strategies works like this.  The formals to \texttt{lambda@} could be
re-ordered to have the last always be \texttt{fk}.  This would mean that
there could be just one argument instead of three.  That one argument would
be a stream of say, \emph{package}s, where a package contains everything
but \texttt{fk}.  Then, each package, which now contains \texttt{sk} and
\texttt{subst} could, in turn, be treated as a stream of \emph{pack}s.  A
pack could be implemented with \texttt{cons}.  Now that these three
variables can be treated like a stream of streams, we can think about
different ways of combining streams to perhaps yield different and
interesting search strategies.  But, this is left as an exercise for the
reader.  Be wary that not every use of \texttt{@} physically takes three
arguments, so there is a little bookkeeping to get this to work.  The main
thing to do is change the \texttt{lambda@} into \texttt{lambda} first.
Once that is running, changing the argument order and turning the data into
streams is simple.

Our goal has been to present the ideas of logic programming without
using a lot of special features of Scheme and without losing the feel
of programming in Scheme.  Now, we can say that the basic unsullied
logic system interface contains five operators: \texttt{relation},
\texttt{extend-relation}, \texttt{all}, \texttt{all!}, and
\texttt{solve}.
\section{Acknowledgments}

This paper would not have been possible without the earlier work on
implementing logic systems with Anurag Mendhekar.  The work with
Anurag led to Jon Rossie's use of our logic system in the development
of his dissertation's results.  His utilization of the tool helped us
understand how we had to weave things together.  But, it wasn't until
work with Mitch Wand and Chris Haynes in \emph{Essentials of
Programming Languages, Second Edition} on the material on unification,
substitutions, and logic programming that it seemed there might be a
chance for a more direct solution.  Steve Ganz's dissertation also
needed an inference system.  Over the years, Steve began to see how we
could make the seamlessness of Scheme possible by showing how to
partition the monolithic relations into functions.  Such a function
then represents a relation that can be invoked as a function.  Next we
noticed that the sullied operators could also be written as functions
with the same interface, thus removing a dispatch.  Once the dispatch
was removed, it was easy to remove the lone remaining search down the
goals.  Discovering that a non-recursive unifier was possible
came much later.  The first implementation and discussion of
polymorphic \texttt{let} is the work of Jeremiah Willcock.  Treating
the consequent of a relation as an goal has been inspired by
Seres and Spivey's paper.  Several fruitful discussions with Venkatesh
Choppella led to more thought about the types in the code of this
logic system.  We are grateful to Oscar Waddell for implementing
\texttt{expand-only}, the partial macro expander.  Regretably, it
cannot be made fully general, however, it does meet our needs.
\end{document}
\bibliography{rollyourown}
\end{document}
