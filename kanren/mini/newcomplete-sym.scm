;;; This file was generated by writeminikanren.pl
;;; Generated at 2006-01-29 15:28:03

;;; Chapter 9 functions (remain as they were):

(define-syntax rhs
  (syntax-rules ()
    ((_ x) (cdr x))))

(define-syntax lhs
  (syntax-rules ()
    ((_ x) (car x))))

(define-syntax size-s
  (syntax-rules ()
    ((_ x) (length x))))

(define-syntax var
  (syntax-rules ()
    ((_ x) (vector x))))

(define-syntax var?
  (syntax-rules ()
    ((_ x) (vector? x))))

(define empty-s '())

(define walk
  (lambda (v s)
    (cond
      ((var? v)
       (let ((a (assq v s)))
         (cond
           (a (walk (rhs a) s))
           (else v))))
      (else v))))

(define ext-s
  (lambda (x v s)
    (cons `(,x . ,v) s)))

(define unify-unchecked
  (lambda (v w s)
    (let ((v (walk v s))
          (w (walk w s)))
      (cond
        ((eq? v w) s)
        ((var? v) (ext-s v w s))
        ((var? w) (ext-s w v s))
        ((and (pair? v) (pair? w))
         (let ((s (unify-unchecked (car v) (car w) s)))
           (and s (unify-unchecked (cdr v) (cdr w) s))))
        ((equal? v w) s)
        (else #f)))))

(define ext-s-check
  (lambda (x v s)
    (cond
      ((occurs-check x v s) #f)
      (else (ext-s x v s)))))

(define occurs-check
  (lambda (x v s)
    (let ((v (walk v s)))
      (cond
        ((var? v) (eq? v x))
        ((pair? v)
         (or
           (occurs-check x (car v) s)
           (occurs-check x (cdr v) s)))
        (else #f)))))

(define unify
  (lambda (v w s)
    (let ((v (walk v s))
          (w (walk w s)))
      (cond
        ((eq? v w) s)
        ((var? v) (ext-s-check v w s))
        ((var? w) (ext-s-check w v s))
        ((and (pair? v) (pair? w))
         (let ((s (unify (car v) (car w) s)))
           (and s (unify (cdr v) (cdr w) s))))
        ((equal? v w) s)
        (else #f)))))

(define walk*
  (lambda (v s)
    (let ((v (walk v s)))
      (cond
        ((var? v) v)
        ((pair? v)
         (cons
           (walk* (car v) s)
           (walk* (cdr v) s)))
        (else v)))))

(define reify-s
  (lambda (v s)
    (let ((v (walk v s)))
      (cond
        ((var? v)
         (ext-s v (reify-name (size-s s)) s))
        ((pair? v) (reify-s (cdr v)
                     (reify-s (car v) s)))
        (else s)))))

(define reify-name
  (lambda (n)
    (string->symbol
      (string-append "_" "." (number->string n)))))

(define walk*
  (lambda (v s)
    (let ((v (walk v s)))
      (cond
        ((var? v) v)
        ((pair? v)
         (cons
           (walk* (car v) s)
           (walk* (cdr v) s)))
        (else v)))))

(define reify
  (lambda (v s)
    (let ((v (walk* v s)))
      (walk* v (reify-s v empty-s)))))

;;; End of chapter 9 functions

; goal: Subst -> Stream
(define-syntax lambdag@
  (syntax-rules ()
    ((_ (s) e) (lambda (s) e))))

; a general-purpose thunk, to delay computations
(define-syntax lambdae@
  (syntax-rules ()
    ((_ () e) (lambda () e))))

; We define the stream of values, our monad, as follows
;; data Stream = Fail | One Subst | Choice Subst Susp
;;             | Inc Susp		-- incomplete answer
;; type Goal = Subst -> Stream
;; type Susp = [Cont]  -- non-empty list of continuations
;; type Cont = (Subst, Goal)

; Thus continuation (Cont a) is a pair whose first component is a partial
; answer (substitution computed so far).
; For representation purposes, we represent Susp as a vector
; whose one component is a list of Cont, the list of pairs.

(define-syntax mzero
  (syntax-rules ()
    ((_) #f)))

(define-syntax unit
  (syntax-rules ()
    ((_ a) a)))

(define-syntax choice
  (syntax-rules ()
    ((_ a f) (cons a f))))

(define susp vector)

; suspension with only one continuation
(define (susp-1 s g) (vector (list (cons s g))))

; extract the list of Cont from Susp
(define (susp-c susp) (vector-ref susp 0))

(define (force-c cont) 			; continue the cont
  ((cdr cont) (car cont)))

; deconstructor of stream

(define-syntax case-inf
  (syntax-rules ()
    ((_ e on-zero ((a^) on-one) ((a f) on-choice) ((i) on-incomplete))
     (let ((r e))
       (cond
         ((not r) on-zero)
         ((vector? r) (let ((i r)) on-incomplete))
         ((and (pair? r) (vector? (cdr r)))
          (let ((a (car r)) (f (cdr r)))
            on-choice))
         (else (let ((a^ r)) on-one)))))))

(define-syntax run
  (syntax-rules ()
    ((_ n (x) g^ g ...) (take n (go (x) g^ g ...)))))

(define-syntax run*
  (syntax-rules ()
    ((_ (x) g ...) (run #f (x) g ...))))

(define take
  (lambda (n e)
    (cond
      ((and n (zero? n)) '())
      (else
        (let ((p (e)))
          (if p
            (cons (car p)
              (take (and n (- n 1)) (cdr p)))
            '()))))))

(define-syntax go  
  (syntax-rules ()
    ((_ (x) g^ g ...)
     (let ((x (var 'x)))
       (map-inf (lambda (s) (reify x s))
	 (susp-1 empty-s (all g^ g ...)))))))


(define map-inf
  (lambda (p f)
    (lambdae@ ()
      (let loop ((ks (susp-c f)))
	(if (null? ks) #f
	  (let* ((k1 (car ks)) (ks (cdr ks)))
	    (case-inf (force-c k1)
	      (loop ks)
	      ((s) (cons (p s) (lambdae@ () (loop ks))))
	      ((s f) (cons (p s) (lambdae@ () (loop (append (susp-c f) ks)))))
	      ((i) (loop (append ks (susp-c i)))))))))))

(define succeed (lambdag@ (s) (unit s)))

(define fail (lambdag@ (s) (mzero)))

(define-syntax fresh
  (syntax-rules ()
    ((_ (x ...) g^ g ...)
     (lambdag@ (s)
       (let ((x (var 'x)) ...)
         ((all g^ g ...) s))))))

;; This associates to the left
;; (define-syntax all
;;   (syntax-rules ()
;;     ((_) succeed)
;;     ((_ g) g)
;;     ((_ g1 g2) (conj g1 g2))
;;     ((_ g^ g g* ...)
;;      (all (let ((g0 g^)) (lambdag@ (s) (bind (g0 s) g))) g* ...))))

; We associate conjunctions to the right
(define-syntax all
  (syntax-rules ()
    ((_) succeed)
    ((_ g) g)
    ((_ g1 g2) (conj g1 (downgrade g2)))
    ((_ g^ g* ...)
     (let ((g0 g^)) (lambdag@ (s) (bind (g0 s) (downgrade (all g* ...))))))))

(define (conj g1 g2) (lambdag@ (s) (bind (g1 s) g2)))
(define (susp-g g) (lambdag@ (s) (susp-1 s g)))

(define (downgrade g)
  (lambdag@ (s)
    (case-inf (g s)
      (mzero)
      ((s) (unit s))
      ((s k) (choice s k))
      ((k)
	(susp
	  (map (lambda (cont)
		 (cons (car cont)
		   (susp-g (downgrade (cdr cont)))))
	    (susp-c k)))))))


;; (define anyo
;;   (lambda (g)
;;     (conde
;;       (g succeed)
;;       (else (anyo g)))))

;; (define nevero (anyo fail))
;; (define alwayso (anyo succeed))

;; (run 1 (q) alwayso)
;; ; (_.0)
;; (run 1 (q) alwayso fail)
;; ; ()

;; (run 1 (q) fail alwayso)
;; ; ()


(define ==
  (lambda (v w)
    (lambdag@ (s)
      (unify v w s))))

(define ==-unchecked
  (lambda (v w)
    (lambdag@ (s)
      (unify-unchecked v w s))))

(define-syntax conde
  (syntax-rules (else)
    ((_) fail)
    ((_ (else g0 g ...)) (all g0 g ...))
    ((_ (g0 g ...) c ...)
     (lambdag@ (s)
       (mplus
         ((all g0 g ...) s)
	 (list (cons s (conde c ...))))))))

; See Symm.hs
(define bind
  (lambda (s-inf g2)
    (case-inf s-inf
      (mzero)
      ((s) (susp-1 s g2))
      ((s k1) (mplus (g2 s) (bind-asymm* k1 g2)))
      ((k1) (susp (bind-symm* k1 g2))))))

; This corresponds to the symmetric conjunction 
(define (bind-symm* k1 g2)
  (map (lambda (cont) (cons (car cont) (conj g2 (cdr cont))))
    (susp-c k1)))

; This corresponds to the usual, non-symmetric conjunction
(define (bind-asymm* k1 g2)
  (map (lambda (cont) (cons (car cont) (conj (cdr cont) g2)))
    (susp-c k1)))


; See mplus' and mplus'' in Symm.hs
(define mplus
  (lambda (s-inf ks)
    (case-inf s-inf
      (susp ks)
      ((s) (choice s (susp ks)))
      ((s k1) (choice s (susp (merge-ks ks (susp-c k1)))))
      ((k1) (susp (merge-ks ks (susp-c k1)))))))

'(define mplus
  (lambda (s-inf ks)
    (case-inf s-inf
      (susp ks)
      ((s) (choice s (susp ks)))
      ((s k1) (choice s (susp (merge-ks ks (susp-c k1)))))
      ((k1) 
	(let ((k (car ks)) (ks (cdr ks)) (k1 (susp-c k1)))
	  (case-inf (force-c k)
	    (susp (merge-ks k1 ks))
	    ((s) (choice s (susp (merge-ks k1 ks))))
	    ((s k2) (choice s (susp (merge-ks k1 (merge-ks (susp-c k2) ks)))))
	    ((k2) (susp (merge-ks k1 (merge-ks (susp-c k2) ks))))))))))


;; (define mplus
;;   (lambda (s-inf ks)
;;     (display "mplus") (newline)
;;     (let loop ((s-inf s-inf) (ks ks) (b #t))
;;       (display "s-inf") (write s-inf) (newline)
;;       (case-inf s-inf
;;         (susp ks)
;;         ((s) (choice s (susp ks)))
;;         ((s k1) (choice s (merge-ks ks (susp-c k1))))
;;         ((k1)
;; 	  (if b
;; 	    (let ((cont2 (car ks)) (k2 (cdr ks)))
;; 	      (loop (force-c cont2) (merge-ks (susp-c k1) k2) #f))
;; 	    (susp (merge-ks (susp-c k1) ks))))))))

'(define (merge-ks k1 k2)
  ;(display "merge-ks") (newline)
  (cond
    ((null? k1) k2)
    ((null? k2) k1)
    (else (cons (car k1) (cons (car k2) (merge-ks (cdr k1) (cdr k2)))))))

(define (merge-ks k1 k2) (append k1 k2))

                            
(define-syntax project
  (syntax-rules ()
    ((_ (x ...) g^ g ...)
     (lambdag@ (s)
       (let ((x (walk* x s)) ...)
         ((all g^ g ...) s))))))

;; (define-syntax conda
;;   (syntax-rules (else)
;;     ((_) fail)
;;     ((_ (else g ...)) (all g ...))
;;     ((_ (g0 g ...) c ...) (ifa g0 (all g ...) (conda c ...)))))

;; (define-syntax condu
;;   (syntax-rules (else)
;;     ((_) fail)
;;     ((_ (else g ...)) (all g ...))
;;     ((_ (g0 g ...) c ...) (ifu g0 (all g ...) (condu c ...)))))

;; (define-syntax ifa
;;   (syntax-rules ()
;;     ((_ g0 g1 g2)
;;      (lambdag@ (s)
;;        (let loop ((s-inf (g0 s)))
;;          (case-inf s-inf
;;            (g2 s)
;;            ((s) (g1 s))
;;            ((s f) (bind s-inf g1))
;;            ((i) (map-cont i (i s) (loop (i s))))))))))

;; (define-syntax ifu
;;   (syntax-rules ()
;;     ((_ g0 g1 g2)
;;      (lambdag@ (s)
;;        (let loop ((s-inf (g0 s)))
;;          (case-inf s-inf
;;            (g2 s)
;;            ((s) (g1 s))
;;            ((s f) (g1 s))
;;            ((i) (map-cont i (i s) (loop (i s))))))))))


;;; For backward compatibility.
; Just the lambda...
(define-syntax lambda-limited
  (syntax-rules ()
    ((_ n formals g) (lambda formals g))))

(define-syntax alli
  (syntax-rules ()
    ((_ args ...) (all args ...))))

(define-syntax condi
  (syntax-rules ()
    ((_ args ...) (conde args ...))))

(define-syntax condw
  (syntax-rules ()
    ((_ args ...) (conde args ...))))

