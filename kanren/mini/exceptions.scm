; Exceptions in Kanren
; Implementing ISO-like exceptions in Kanren, but preserving, rather
; than discarding choice points upon throwing an exception.
;
; Here is the ISO Prolog specification of exception handling
; (quoted from the ISO Prolog documentation)
;   catch(:Goal, +Catcher, :Recover)                                  [ISO]
;     Behaves  as call/1 if  no exception is  raised when executing  Goal.
;     If  an exception is  raised using throw/1  while Goal executes,  and
;     the  Goal is the innermost goal  for which Catcher unifies with  the
;     argument  of throw/1, all choice-points  generated by Goal are  cut,
;     the  system backtracks to the start of catch/3 while  preserving the
;     thrown exception term and Recover is called as in call/1.
;
;     The  overhead of calling a  goal through catch/3 is very  comparable
;     to  call/1.  Recovery from  an exception is much slower,  especially
;     if the exception-term is large due to the copying thereof.
;
;   throw(+Exception)                                                 [ISO]
;     Raise  an exception.   The  system looks  for the innermost  catch/3
;     ancestor  for which Exception unifies  with the Catcher argument  of
;     the catch/3 call.  See catch/3 for details.
;
;     ISO  demands throw/1 to make a copy of Exception, walk up  the stack
;     to a catch/3 call,  backtrack and try to unify the copy of Exception
;     with  Catcher.   SWI-Prolog delays  making a  copy of Exception  and
;     backtracking  until it actually found a matching catch/3 goal.   The
;     advantage  is that we can start  the debugger at the first  possible
;     location  while preserving the entire exception context if  there is
;     no  matching catch/3  goal.   This  approach can  lead to  different
;     behaviour  if Goal and Catcher of catch/3 call share variables.   We
;     assume this to be  highly unlikely and could not think of a scenario
;     where this is useful.
;
; This present file implements catch/3 and throw/1 as described above,
; with the following differences:
;  -- Choice-points are not discarded when the exception is raised;
;  -- Hence, we do not have to copy the exception object;
;  -- Recovery from an exception is cheap.
;
; Kanren is based on the LogicT monad, which could be extended to
; (ErrorT . LogicT) by re-defining the bind operation of Kanren.
; The following Scheme code is the transcription of the implementation
; of LogicT t => ErrorT (t m) at the end of ../continuations/GenCode.hs

; Please make sure to load the Kanren implementation FIRST:
; http://kanren.cvs.sourceforge.net/viewvc/kanren/kanren/mini/mk.scm


; Define the marker for an exceptional condition
; and its constructors and deconstructors

(define (make-exc exc-term s)
  (vector exc-term s))

(define exc? vector?)

(define (exc-get-term e) (vector-ref e 0))
(define (exc-get-s e)    (vector-ref e 1))


; Re-define Kanren primitives so to propagate the exception
(define == 
  (lambda (v w)
    (lambdag@ (s)
      (cond
	((exc? s) s)
        ((unify v w s) => succeed)
        (else (fail s))))))

(define ==-check
  (lambda (v w)
    (lambdag@ (s)
      (cond
	((exc? s) s)
        ((unify-check v w s) => succeed)
        (else (fail s))))))

(define bind
  (lambda (a-inf g)
    (case-inf a-inf
      (mzero) 
      ((a) (if (exc? a) a (g a)))
      ((a f) (mplus (if (exc? a) a (g a))
               (lambdaf@ () (bind (f) g)))))))

(define bindi
  (lambda (a-inf g)
    (case-inf a-inf
      (mzero)
      ((a) (if (exc? a) a (g a)))
      ((a f) (mplusi (if (exc? a) a (g a))
               (lambdaf@ () (bindi (f) g)))))))

; Define the exception-handling predicates

; The following implementation mirrors the Haskell code
(define (catch goal catcher recover)
  (define old-bind			; Original bind from mk.scm
    (lambda (a-inf g)
      (case-inf a-inf
	(mzero) 
	((a) (g a))
	((a f) (mplus (g a)
		 (lambdaf@ () (old-bind (f) g)))))))
  (define check-exc
    (lambdag@ (s)
      (if (exc? s)
	(cond
	  ((unify catcher (exc-get-term s) (exc-get-s s)) => recover)
	  (else (unit s)))                ; propagate
	(unit s))))
  (lambdag@ (s) 
    (old-bind (goal s) check-exc)))

  
; The following is the optimal version of the above, after
; a bit of inlining and simplifications

;; (define (catch goal catcher recover)
;;   (define (check-exc s)
;;     (if (exc? s)
;;       (cond
;; 	((unify catcher (exc-get-term s) (exc-get-s s)) => recover)
;; 	(else (unit s)))                ; propagate
;;       (unit s)))
;;   (define (handle s)
;;     (case-inf s
;;       (mzero)
;;       ((a) (check-exc a))
;;       ((a f) (mplus (check-exc a)
;; 	       (lambdaf@ () (handle (f)))))))
;;   (lambdag@ (s)
;;     (handle (goal s))))

(define (throw exc-term)
  (lambdag@ (s)
    (make-exc exc-term s)))

; ------------------------------------------------------------------------
;		Tests and illustrations

(run #f (q) (catch (throw 1) q succeed))
; (1)

(run #f (q) (catch (all (== q 1) (throw 1)) q succeed))
; (1)

(run #f (q) (catch (all fail (throw 1)) q succeed))
; ()

(run #f (q) (catch (all (throw 1) fail) q succeed))
; (1)

(run #f (q) (catch (all (throw 1) (== q 2)) q succeed))
; (1)

(run #f (q) (catch (all (anye succeed (throw 1)) (== q 2)) q succeed))
; (2 1)

(run #f (q) (catch (all (anye (throw 10) (throw 1)) (== q 2)) q succeed))
; (10 1)


(run #f (q)
  (fresh (y)
  (catch 
    (fresh (x)
      (conde
	(succeed (== x 1))
	(succeed (== x 2))
 	(succeed (== x 3) (throw `(e1 5)))
 	(succeed (== x 4) (throw `(e1 15)))
	(succeed (== x 5)))
      (== q `(no-exc ,x)))
    `(e1 ,y)
    (== q `(caught 1 ,y)))))

;; ((no-exc 1)
;;  (no-exc 2)
;;  (caught 1 5)
;;  (caught 1 15)
;;  (no-exc 5))


; nested catch
(run #f (q)
  (fresh (y)
  (catch 
    ; inner, catching e1
    (catch 
      (fresh (x)
	(conde
	  (succeed (== x 1))
	  (succeed (== x 2))
	  (succeed (== x 3) (throw `(e1 5)))
	  (succeed (== x 4) (throw `(e2 15)))
	  (succeed (== x 5)))
	(== q `(no-exc ,x)))
      `(e1 ,y)
      (== q `(caught 1 ,y)))
    `(e2 ,y)
    (== q `(caught 2 ,y)))))

;; ((no-exc 1)
;;  (no-exc 2)
;;  (caught 1 5)
;;  (caught 2 15)
;;  (no-exc 5))

