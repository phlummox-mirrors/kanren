;;; This file was generated by writeminikanren.pl
;;; Generated at 2006-01-29 15:28:03

;;; Chapter 9 functions:

(define-syntax rhs
  (syntax-rules ()
    ((_ x) (cdr x))))

(define-syntax lhs
  (syntax-rules ()
    ((_ x) (car x))))

(define-syntax size-s
  (syntax-rules ()
    ((_ x) (length x))))

(define-syntax var
  (syntax-rules ()
    ((_ x) (vector x))))

(define-syntax var?
  (syntax-rules ()
    ((_ x) (vector? x))))

(define empty-s '())

(define walk
  (lambda (v s)
    (cond
      ((var? v)
       (let ((a (assq v s)))
         (cond
           (a (walk (rhs a) s))
           (else v))))
      (else v))))

(define ext-s
  (lambda (x v s)
    (cons `(,x . ,v) s)))

(define unify-unchecked
  (lambda (v w s)
    (let ((v (walk v s))
          (w (walk w s)))
      (cond
        ((eq? v w) s)
        ((var? v) (ext-s v w s))
        ((var? w) (ext-s w v s))
        ((and (pair? v) (pair? w))
         (let ((s (unify-unchecked (car v) (car w) s)))
           (and s (unify-unchecked (cdr v) (cdr w) s))))
        ((equal? v w) s)
        (else #f)))))

(define ext-s-check
  (lambda (x v s)
    (cond
      ((occurs-check x v s) #f)
      (else (ext-s x v s)))))

(define occurs-check
  (lambda (x v s)
    (let ((v (walk v s)))
      (cond
        ((var? v) (eq? v x))
        ((pair? v)
         (or
           (occurs-check x (car v) s)
           (occurs-check x (cdr v) s)))
        (else #f)))))

(define unify
  (lambda (v w s)
    (let ((v (walk v s))
          (w (walk w s)))
      (cond
        ((eq? v w) s)
        ((var? v) (ext-s-check v w s))
        ((var? w) (ext-s-check w v s))
        ((and (pair? v) (pair? w))
         (let ((s (unify (car v) (car w) s)))
           (and s (unify (cdr v) (cdr w) s))))
        ((equal? v w) s)
        (else #f)))))

(define walk*
  (lambda (v s)
    (let ((v (walk v s)))
      (cond
        ((var? v) v)
        ((pair? v)
         (cons
           (walk* (car v) s)
           (walk* (cdr v) s)))
        (else v)))))

(define reify-s
  (lambda (v s)
    (let ((v (walk v s)))
      (cond
        ((var? v)
         (ext-s v (reify-name (size-s s)) s))
        ((pair? v) (reify-s (cdr v)
                     (reify-s (car v) s)))
        (else s)))))

(define reify-name
  (lambda (n)
    (string->symbol
      (string-append "_" "." (number->string n)))))

(define walk*
  (lambda (v s)
    (let ((v (walk v s)))
      (cond
        ((var? v) v)
        ((pair? v)
         (cons
           (walk* (car v) s)
           (walk* (cdr v) s)))
        (else v)))))

(define reify
  (lambda (v s)
    (let ((v (walk* v s)))
      (walk* v (reify-s v empty-s)))))

;;; End of chapter 9 functions

(define-syntax lambdag@
  (syntax-rules ()
    ((_ (s) e) (lambda (s) e))))

(define-syntax lambdaf@
  (syntax-rules ()
    ((_ () e) (lambda () e))))

(define-syntax lambdae@
  (syntax-rules ()
    ((_ () e) (lambda () e))))

;;; This is sort of incomplete.
(define-syntax lambdai@
  (syntax-rules ()
    ((_ () e) (lambdaf@ () e))))

(define-syntax mzero
  (syntax-rules ()
    ((_) #f)))

(define-syntax unit
  (syntax-rules ()
    ((_ a) a)))

(define-syntax choice
  (syntax-rules ()
    ((_ a f) (cons a f))))

(define-syntax case-inf
  (syntax-rules ()
    ((_ e on-zero ((a^) on-one) ((a f) on-choice) ((i) on-incomplete))
     (let ((r e))
       (cond
         ((not r) on-zero)
         ((procedure? r) (let ((i r)) on-incomplete))
         ((and (pair? r) (procedure? (cdr r)))
          (let ((a (car r)) (f (cdr r)))
            on-choice))
         (else (let ((a^ r)) on-one)))))))

(define-syntax run
  (syntax-rules ()
    ((_ n (x) g^ g ...) (take n (go (x) g^ g ...)))))

(define-syntax run*
  (syntax-rules ()
    ((_ (x) g ...) (run #f (x) g ...))))

(define take
  (lambda (n e)
    (cond
      ((and n (zero? n)) '())
      (else
        (let ((p (e)))
          (if p
            (cons (car p)
              (take (and n (- n 1)) (cdr p)))
            '()))))))

(define-syntax go  
  (syntax-rules ()
    ((_ (x) g^ g ...)
     (let ((x (var 'x)))
       (map-inf (lambda (s) (reify x s))
         (lambdaf@ () ((all g^ g ...) empty-s)))))))

(define map-inf
  (lambda (p f)
    (lambdae@ ()
      (case-inf (f)
        #f
        ((s) (cons (p s) (lambdae@ () #f)))
        ((s f) (cons (p s) (map-inf p f)))
        ((i) ((map-inf p i)))))))

(define succeed (lambdag@ (s) (unit s)))

(define fail (lambdag@ (s) (mzero)))

(define-syntax fresh
  (syntax-rules ()
    ((_ (x ...) g^ g ...)
     (lambdag@ (s)
       (let ((x (var 'x)) ...)
         ((all g^ g ...) s))))))

(define-syntax all
  (syntax-rules ()
    ((_) succeed)
    ((_ g) g)
    ((_ g^ g g* ...)
     (all (let ((g0 g^)) (lambdag@ (s) (bind (g0 s) g))) g* ...))))

(define-syntax allw
  (syntax-rules ()
    ((_) succeed)
    ((_ g) g)
    ((_ g^ g g* ...)
     (allw (lambdag@ (s)
             (let ((g1 g^) (g2 g))
               (amb
                 (lambdai@ () ((all g1 g2) s))
                 (lambdai@ () ((all g2 g1) s)))))
       g* ...))))

(define amb
  (lambda (i j)
    (case-inf i
      (mzero)
      ((s) (unit s))
      ((s f) (choice s f))
      ((i) (case-inf j
             (mzero)
             ((s) (unit s))
             ((s f) (choice s f))
             ((j) (lambdai@ () (amb (i) (j)))))))))

(define ==
  (lambda (v w)
    (lambdag@ (s)
      (unify v w s))))

(define ==-unchecked
  (lambda (v w)
    (lambdag@ (s)
      (unify-unchecked v w s))))

(define-syntax conde
  (syntax-rules (else)
    ((_) fail)
    ((_ (else g0 g ...)) (all g0 g ...))
    ((_ (g0 g ...) c ...)
     (lambdag@ (s)
       (mplus
         (lambdai@ () ((all g0 g ...) s))
         (lambdaf@ () ((conde c ...) s)))))))

(define bind
  (lambda (s-inf g)
    (case-inf s-inf
      (mzero)
      ((s) (g s))
      ((s f) (mplus (g s) (lambdaf@ () (bind (f) g))))
      ((i) (lambdai@ () (bind (i) g))))))

;;; This seems a lot simpler, but may have type problems
(define mplus
  (lambda (s-inf f)
    (let loop ((s-inf s-inf) (f f) (b #t))
      (case-inf s-inf
        f
        ((s) (choice s f))
        ((s f^) (choice s (lambdaf@ () (loop (f) f^ #t))))
        ((i) (lambdai@ () (if b (loop (i) f #f) (loop (f) i #t))))))))
                            
(define-syntax project
  (syntax-rules ()
    ((_ (x ...) g^ g ...)
     (lambdag@ (s)
       (let ((x (walk* x s)) ...)
         ((all g^ g ...) s))))))

(define-syntax conda
  (syntax-rules (else)
    ((_) fail)
    ((_ (else g ...)) (all g ...))
    ((_ (g0 g ...) c ...) (ifa g0 (all g ...) (conda c ...)))))

(define-syntax condu
  (syntax-rules (else)
    ((_) fail)
    ((_ (else g ...)) (all g ...))
    ((_ (g0 g ...) c ...) (ifu g0 (all g ...) (condu c ...)))))

(define-syntax ifa
  (syntax-rules ()
    ((_ g0 g1 g2)
     (lambdag@ (s)
       (let loop ((s-inf (g0 s)))
         (case-inf s-inf
           (g2 s)
           ((s) (g1 s))
           ((s f) (bind s-inf g1))
           ((i) (lambdai@ () (loop (i))))))))))

(define-syntax ifu
  (syntax-rules ()
    ((_ g0 g1 g2)
     (lambdag@ (s)
       (let loop ((s-inf (g0 s)))
         (case-inf s-inf
           (g2 s)
           ((s) (g1 s))
           ((s f) (g1 s))
           ((i) (lambdai@ () (loop (i))))))))))

;;; For backward compatibility.
; Just the lambda...
(define-syntax lambda-limited
  (syntax-rules ()
    ((_ n formals g) (lambda formals g))))

(define-syntax alli
  (syntax-rules ()
    ((_ args ...) (all args ...))))

(define-syntax condi
  (syntax-rules ()
    ((_ args ...) (conde args ...))))

(define-syntax condw
  (syntax-rules ()
    ((_ args ...) (conde args ...))))

